[[_sec_option_types]]
= Options Types


Option types are a way to put constraints on the values a module option can take.
Types are also responsible of how values are merged in case of multiple value definitions. 

[[_sec_option_types_basic]]
== Basic Types


Basic types are the simplest available types in the module system.
Basic types include multiple string types that mainly differ in how definition merging is handled. 

[var]``types.attrs``::
A free-form attribute set. 

[var]``types.bool``::
A boolean, its values can be `true` or ``false``. 

[var]``types.path``::
A filesystem path, defined as anything that when coerced to a string starts with a slash.
Even if derivations can be considered as path, the more specific `types.package` should be preferred. 

[var]``types.package``::
A derivation or a store path. 


Integer-related types: 

[var]``types.int``::
A signed integer. 

[var]``types.ints.{s8, s16, s32}``::
Signed integers with a fixed length (8, 16 or 32 bits). They go from 
to 
respectively (e.g. `âˆ’128` to `127` for 8 bits). 

[var]``types.ints.unsigned``::
An unsigned integer (that is >= 0). 

[[_types.ints.ux]]
[var]``types.ints.{u8, u16, u32}``::
Unsigned integers with a fixed length (8, 16 or 32 bits). They go from 
to 
respectively (e.g. `0` to `255` for 8 bits). 

[var]``types.ints.positive``::
A positive integer (that is > 0). 

[var]``types.port``::
A port number.
This type is an alias to <<_types.ints.ux,[var]``types.ints.u16``>>. 


String-related types: 

[var]``types.str``::
A string.
Multiple definitions cannot be merged. 

[var]``types.lines``::
A string.
Multiple definitions are concatenated with a new line ``"\n"``. 

[var]``types.commas``::
A string.
Multiple definitions are concatenated with a comma ``","``. 

[var]``types.envVar``::
A string.
Multiple definitions are concatenated with a collon ``":"``. 

[var]``types.strMatching``::
A string matching a specific regular expression.
Multiple definitions cannot be merged.
The regular expression is processed using ``builtins.match``. 


[[_sec_option_types_value]]
== Value Types


Value types are types that take a value parameter. 

[var]``types.enum``[replaceable]``l``::
One element of the list [replaceable]``l``, e.g. ``types.enum [ "left" "right" ]``.
Multiple definitions cannot be merged. 

[var]``types.separatedString``[replaceable]``sep``::
A string with a custom separator [replaceable]``sep``, e.g. ``types.separatedString "|"``. 

[var]``types.ints.between``[replaceable]``lowest``[replaceable]``highest``::
An integer between [replaceable]``lowest`` and [replaceable]``highest`` (both inclusive). Useful for creating types like ``types.port``. 

[var]``types.submodule``[replaceable]``o``::
A set of sub options [replaceable]``o``. [replaceable]``o`` can be an attribute set, a function returning an attribute set, or a path to a file containing such a value.
Submodules are used in composed types to create modular options.
This is equivalent to ``types.submoduleWith { modules = toList o; shorthandOnlyDefinesConfig = true; }``.
Submodules are detailed in <<_section_option_types_submodule>>. 

[var]``types.submoduleWith`` { [replaceable]``modules``, [replaceable]``specialArgs`` ? {}, [replaceable]``shorthandOnlyDefinesConfig`` ? false }::
Like [var]``types.submodule``, but more flexible and with better defaults.
It has parameters 
+
** [replaceable]``modules`` A list of modules to use by default for this submodule type. This gets combined with all option definitions to build the final list of modules that will be included. 
+
NOTE: Only options defined with this argument are included in rendered documentation. 
+

** [replaceable]``specialArgs`` An attribute set of extra arguments to be passed to the module functions. The option `\_module.args` should be used instead for most arguments since it allows overriding. [replaceable]``specialArgs`` should only be used for arguments that can't go through the module fixed-point, because of infinite recursion or other problems. An example is overriding the [var]``lib`` argument, because [var]``lib`` itself is used to define ``\_module.args``, which makes using `\_module.args` to define it impossible. 
** [replaceable]``shorthandOnlyDefinesConfig`` Whether definitions of this type should default to the `config` section of a module (see <<_ex_module_syntax>>) if it is an attribute set. Enabling this only has a benefit when the submodule defines an option named `config` or ``options``. In such a case it would allow the option to be set with `the-submodule.config = "value"` instead of requiring ``the-submodule.config.config = "value"``. This is because only when modules _don't_ set the `config` or `options` keys, all keys are interpreted as option definitions in the `config` section. Enabling this option implicitly puts all attributes in the `config` section. 
+ 
With this option enabled, defining a non-``config`` section requires using a function: ``the-submodule = { ... }: { options = { ... }; }``. 



[[_sec_option_types_composed]]
== Composed Types


Composed types are types that take a type as parameter. `listOf
   int` and `either int str` are examples of composed types. 

[var]``types.listOf``[replaceable]``t``::
A list of [replaceable]``t`` type, e.g. ``types.listOf
int``.
Multiple definitions are merged with list concatenation. 

[var]``types.attrsOf``[replaceable]``t``::
An attribute set of where all the values are of [replaceable]``t`` type.
Multiple definitions result in the joined attribute set. 
+
NOTE: This type is _strict_ in its values, which in turn means attributes cannot depend on other attributes.
See [var]``
       types.lazyAttrsOf`` for a lazy version. 
+



[var]``types.lazyAttrsOf``[replaceable]``t``::
An attribute set of where all the values are of [replaceable]``t`` type.
Multiple definitions result in the joined attribute set.
This is the lazy version of [var]``types.attrsOf
``, allowing attributes to depend on each other. 
+
WARNING: This version does not fully support conditional definitions! With an option [var]``foo`` of this type and a definition ``foo.attr = lib.mkIf false 10``, evaluating `foo ? attr` will return `true` even though it should be false.
Accessing the value will then throw an error.
For types [replaceable]``t`` that have an `emptyValue` defined, that value will be returned instead of throwing an error.
So if the type of `foo.attr` was ``lazyAttrsOf (nullOr int)``, `null` would be returned instead for the same `mkIf false` definition. 
+



[var]``types.loaOf``[replaceable]``t``::
An attribute set or a list of [replaceable]``t`` type.
Multiple definitions are merged according to the value. 

[var]``types.nullOr``[replaceable]``t``::
`null` or type [replaceable]``t``.
Multiple definitions are merged according to type [replaceable]``t``. 

[var]``types.uniq``[replaceable]``t``::
Ensures that type [replaceable]``t`` cannot be merged.
It is used to ensure option definitions are declared only once. 

[var]``types.either``[replaceable]``t1``[replaceable]``t2``::
Type [replaceable]``t1`` or type [replaceable]``t2``, e.g. ``with types; either int str``.
Multiple definitions cannot be merged. 

[var]``types.oneOf`` [ [replaceable]``t1``[replaceable]``t2`` ... ]::
Type [replaceable]``t1`` or type [replaceable]``t2`` and so forth, e.g. ``with types; oneOf [ int str bool ]``.
Multiple definitions cannot be merged. 

[var]``types.coercedTo``[replaceable]``from``[replaceable]``f``[replaceable]``to``::
Type [replaceable]``to`` or type [replaceable]``from`` which will be coerced to type [replaceable]``to`` using function [replaceable]``f`` which takes an argument of type [replaceable]``from`` and return a value of type [replaceable]``to``.
Can be used to preserve backwards compatibility of an option if its type was changed. 


[[_section_option_types_submodule]]
== Submodule

`submodule` is a very powerful type that defines a set of sub-options that are handled like a separate module. 

It takes a parameter [replaceable]``o``, that should be a set, or a function returning a set with an `options` key defining the sub-options.
Submodule option definitions are type-checked accordingly to the `options` declarations.
Of course, you can nest submodule option definitons for even higher modularity. 

The option set can be defined directly (<<_ex_submodule_direct>>) or as reference (<<_ex_submodule_reference>>). 

[[_ex_submodule_direct]]
.Directly defined submodule
====
----
options.mod = mkOption {
  description = "submodule example";
  type = with types; submodule {
    options = {
      foo = mkOption {
        type = int;
      };
      bar = mkOption {
        type = str;
      };
    };
  };
};
----
====

[[_ex_submodule_reference]]
.Submodule defined as a reference
====
----
let
  modOptions = {
    options = {
      foo = mkOption {
        type = int;
      };
      bar = mkOption {
        type = int;
      };
    };
  };
in
options.mod = mkOption {
  description = "submodule example";
  type = with types; submodule modOptions;
};
----
====


The `submodule` type is especially interesting when used with composed types like `attrsOf` or ``listOf``.
When composed with `listOf` (<<_ex_submodule_listof_declaration>>), `submodule` allows multiple definitions of the submodule option set (<<_ex_submodule_listof_definition>>). 

[[_ex_submodule_listof_declaration]]
.Declaration of a list of submodules
====
----
options.mod = mkOption {
  description = "submodule example";
  type = with types; listOf (submodule {
    options = {
      foo = mkOption {
        type = int;
      };
      bar = mkOption {
        type = str;
      };
    };
  });
};
----
====

[[_ex_submodule_listof_definition]]
.Definition of a list of submodules
====
----
config.mod = [
  { foo = 1; bar = "one"; }
  { foo = 2; bar = "two"; }
];
----
====


When composed with `attrsOf` (<<_ex_submodule_attrsof_declaration>>), `submodule` allows multiple named definitions of the submodule option set (<<_ex_submodule_attrsof_definition>>). 

[[_ex_submodule_attrsof_declaration]]
.Declaration of attribute sets of submodules
====
----
options.mod = mkOption {
  description = "submodule example";
  type = with types; attrsOf (submodule {
    options = {
      foo = mkOption {
        type = int;
      };
      bar = mkOption {
        type = str;
      };
    };
  });
};
----
====

[[_ex_submodule_attrsof_definition]]
.Declaration of attribute sets of submodules
====
----
config.mod.one = { foo = 1; bar = "one"; };
config.mod.two = { foo = 2; bar = "two"; };
----
====

[[_sec_option_types_extending]]
== Extending types


Types are mainly characterized by their `check` and `merge` functions. 

[var]``check``::
The function to type check the value.
Takes a value as parameter and return a boolean.
It is possible to extend a type check with the `addCheck` function (<<_ex_extending_type_check_1>>), or to fully override the check function (<<_ex_extending_type_check_2>>). 
+


[[_ex_extending_type_check_1]]
.Adding a type check
====
----
byte = mkOption {
  description = "An integer between 0 and 255.";
  type = types.addCheck types.int (x: x >= 0 && x <= 255);
};
----
====
+

[[_ex_extending_type_check_2]]
.Overriding a type check
====
----
nixThings = mkOption {
  description = "words that start with 'nix'";
  type = types.str // {
    check = (x: lib.hasPrefix "nix" x)
  };
};
----
====
[var]``merge``::
Function to merge the options values when multiple values are set.
The function takes two parameters, `loc` the option path as a list of strings, and `defs` the list of defined values as a list.
It is possible to override a type merge function for custom needs. 


[[_sec_option_types_custom]]
== Custom Types


Custom types can be created with the `mkOptionType` function.
As type creation includes some more complex topics such as submodule handling, it is recommended to get familiar with [path]``types.nix``
 code before creating a new type. 

The only required parameter is ``name``. 

[var]``name``::
A string representation of the type function name. 

[var]``definition``::
Description of the type used in documentation.
Give information of the type and any of its arguments. 

[var]``check``::
A function to type check the definition value.
Takes the definition value as a parameter and returns a boolean indicating the type check result, `true` for success and `false` for failure. 

[var]``merge``::
A function to merge multiple definitions values.
Takes two parameters: 

[replaceable]``loc``:::
The option path as a list of strings, e.g. ``["boot" "loader
"grub" "enable"]``. 

[replaceable]``defs``:::
The list of sets of defined `value` and `file` where the value was defined, e.g. ``[ {
file = "/foo.nix"; value = 1; } { file = "/bar.nix"; value = 2 }
]``.
The `merge` function should return the merged value or throw an error in case the values are impossible or not meant to be merged. 

[var]``getSubOptions``::
For composed types that can take a submodule as type parameter, this function generate sub-options documentation.
It takes the current option prefix as a list and return the set of sub-options.
Usually defined in a recursive manner by adding a term to the prefix, e.g. `prefix:
elemType.getSubOptions (prefix ++
[[replaceable]``"prefix"``])` where [replaceable]``"prefix"`` is the newly added prefix. 

[var]``getSubModules``::
For composed types that can take a submodule as type parameter, this function should return the type parameters submodules.
If the type parameter is called ``elemType``, the function should just recursively look into submodules by returning ``elemType.getSubModules;``. 

[var]``substSubModules``::
For composed types that can take a submodule as type parameter, this function can be used to substitute the parameter of a submodule type.
It takes a module as parameter and return the type with the submodule options substituted.
It is usually defined as a type function call with a recursive call to ``substSubModules``, e.g for a type `composedType` that take an `elemtype` type parameter, this function should be defined as ``m:
composedType (elemType.substSubModules m)``. 

[var]``typeMerge``::
A function to merge multiple type declarations.
Takes the type to merge `functor` as parameter.
A `null` return value means that type cannot be merged. 

[replaceable]``f``:::
The type to merge ``functor``. 

+
Note: There is a generic `defaultTypeMerge` that work with most of value and composed types. 

[var]``functor``::
An attribute set representing the type.
It is used for type operations and has the following keys: 

[var]``type``:::
The type function. 

[var]``wrapped``:::
Holds the type parameter for composed types. 

[var]``payload``:::
Holds the value parameter for value types.
The types that have a `payload` are the ``enum``, `separatedString` and `submodule` types. 

[var]``binOp``:::
A binary operation that can merge the payloads of two same types.
Defined as a function that take two payloads as parameters and return the payloads merged. 
