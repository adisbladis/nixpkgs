[[_sec_writing_modules]]
= Writing NixOS Modules
:doctype: book
:sectnums:
:toc: left
:icons: font
:experimental:
:sourcedir: .
:imagesdir: ./images


NixOS has a modular system for declarative configuration.
This system combines multiple _modules_ to produce the full system configuration.
One of the modules that constitute the configuration is [path]``/etc/nixos/configuration.nix``
.
Most of the others live in the https://github.com/NixOS/nixpkgs/tree/master/nixos/modules[nixos/modules] subdirectory of the Nixpkgs tree. 

Each NixOS module is a file that handles one logical aspect of the configuration, such as a specific kind of hardware, a service, or network settings.
A module configuration does not have to handle everything from scratch; it can use the functionality provided by other modules for its implementation.
Thus a module can _declare_ options that can be used by other modules, and conversely can _define_ options provided by other modules in its own implementation.
For example, the module https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/security/pam.nix[pam.nix] declares the option [option]``security.pam.services`` that allows other modules (e.g. https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/services/networking/ssh/sshd.nix[sshd.nix]) to define PAM services; and it defines the option [option]``environment.etc`` (declared by https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/system/etc/etc.nix[etc.nix]) to cause files to be created in [path]``/etc/pam.d``
. 
[[_para_module_syn]]
In <<_sec_configuration_syntax>>, we saw the following structure of NixOS modules: 
[source]
----

{ config, pkgs, ... }:

{ option definitions
}
----

This is actually an _abbreviated_ form of module that only defines options, but does not declare any.
The structure of full NixOS modules is shown in <<_ex_module_syntax>>. 

[[_ex_module_syntax]]
.Structure of NixOS Modules
====
[source]
----

{ config, pkgs, ... }: 

{
  imports =
    [ paths of other modules 
    ];

  options = {
    option declarations 
  };

  config = {
    option definitions 
  };
}
----
====


The meaning of each part is as follows. 

     This line makes the current Nix expression a function. The variable
     [var]``pkgs``
 contains Nixpkgs, while [var]``config``

     contains the full system configuration. This line can be omitted if there
     is no reference to [var]``pkgs``
 and [var]``config``

     inside the module.
    

     This list enumerates the paths to other NixOS modules that should be
     included in the evaluation of the system configuration. A default set of
     modules is defined in the file
     [path]``modules/module-list.nix``
. These don't need to be added
     in the import list.
    

     The attribute [var]``
options``
 is a nested set of
     _option declarations_
 (described below).
    

     The attribute [var]``config``
 is a nested set of
     _option definitions_
 (also described below).
    

<<_locate_example>> shows a module that handles the regular update of the "`locate`" database, an index of all files in the file system.
This module declares two options that can be defined by other modules (typically the user`'s [path]``configuration.nix``
): [option]``services.locate.enable`` (whether the database should be updated) and [option]``services.locate.interval`` (when the update should be done). It implements its functionality by defining two options declared by other modules: [option]``systemd.services`` (the set of all systemd services) and [option]``systemd.timers`` (the list of commands to be executed periodically by [command]``systemd``). 

[[_locate_example]]
.NixOS Module for the "`locate`" Service
====
[source]
----

{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.locate;
in {
  options.services.locate = {
    enable = mkOption {
      type = types.bool;
      default = false;
      description = ''
        If enabled, NixOS will periodically update the database of
        files used by the locate command.
      '';
    };

    interval = mkOption {
      type = types.str;
      default = "02:15";
      example = "hourly";
      description = ''
        Update the locate database at this interval. Updates by
        default at 2:15 AM every day.

        The format is described in
        systemd.time
        7.
      '';
    };

    # Other options omitted for documentation
  };

  config = {
    systemd.services.update-locatedb =
      { description = "Update Locate Database";
        path  = [ pkgs.su ];
        script =
          ''
            mkdir -m 0755 -p $(dirname ${toString cfg.output})
            exec updatedb \
              --localuser=${cfg.localuser} \
              ${optionalString (!cfg.includeStore) "--prunepaths='/nix/store'"} \
              --output=${toString cfg.output} ${concatStringsSep " " cfg.extraFlags}
          '';
      };

    systemd.timers.update-locatedb = mkIf cfg.enable
      { description = "Update timer for locate database";
        partOf      = [ "update-locatedb.service" ];
        wantedBy    = [ "timers.target" ];
        timerConfig.OnCalendar = cfg.interval;
      };
  };
}
----
====

include::option-declarations.adoc[leveloffset=1]


include::option-types.adoc[leveloffset=1]


include::option-def.adoc[leveloffset=1]


include::assertions.adoc[leveloffset=1]


include::meta-attributes.adoc[leveloffset=1]


include::importing-modules.adoc[leveloffset=1]


include::replace-modules.adoc[leveloffset=1]
