
[[_sec_language_perl]]
= Perl


Nixpkgs provides a function [var]``buildPerlPackage``, a generic package builder function for any Perl package that has a standard [var]``Makefile.PL``.
It`'s implemented in https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/perl-modules/generic[pkgs/development/perl-modules/generic]. 

Perl packages from CPAN are defined in https://github.com/NixOS/nixpkgs/blob/master/pkgs/top-level/perl-packages.nix[pkgs/top-level/perl-packages.nix], rather than [path]``pkgs/all-packages.nix``
.
Most Perl packages are so straight-forward to build that they are defined here directly, rather than having a separate function for each package called from [path]``perl-packages.nix``
.
However, more complicated packages should be put in a separate file, typically in [path]``pkgs/development/perl-modules``
.
Here is an example of the former: 
[source]
----

ClassC3 = buildPerlPackage rec {
  name = "Class-C3-0.21";
  src = fetchurl {
    url = "mirror://cpan/authors/id/F/FL/FLORA/${name}.tar.gz";
    sha256 = "1bl8z095y4js66pwxnm7s853pi9czala4sqc743fdlnk27kq94gz";
  };
};
----

Note the use of ``mirror://cpan/``, and the `${name}` in the URL definition to ensure that the name attribute is consistent with the source that we`'re actually downloading.
Perl packages are made available in [path]``all-packages.nix``
 through the variable [var]``perlPackages``.
For instance, if you have a package that needs [var]``ClassC3``, you would typically write 
[source]
----

foo = import ../path/to/foo.nix {
  inherit stdenv fetchurl ...;
  inherit (perlPackages) ClassC3;
};
----

in [path]``all-packages.nix``
.
You can test building a Perl package as follows: 
----

$ nix-build -A perlPackages.ClassC3
----[var]``buildPerlPackage`` adds `perl-` to the start of the name attribute, so the package above is actually called ``perl-Class-C3-0.21``.
So to install it, you can say: 
----

$ nix-env -i perl-Class-C3
----

(Of course you can also install using the attribute name: ``nix-env -i -A perlPackages.ClassC3``.) 

So what does [var]``buildPerlPackage`` do? It does the following: 

. In the configure phase, it calls `perl Makefile.PL` to generate a Makefile. You can set the variable [var]``makeMakerFlags`` to pass flags to [path]``Makefile.PL``
. It adds the contents of the [var]``PERL5LIB`` environment variable to `\#! .../bin/perl` line of Perl scripts as `-I[replaceable]``dir``` flags. This ensures that a script can find its dependencies. (This can cause this shebang line to become too long for Darwin to handle; see the note below.) 
. In the fixup phase, it writes the propagated build inputs ([var]``propagatedBuildInputs``) to the file [path]``$out/nix-support/propagated-user-env-packages`` . [command]``nix-env`` recursively installs all packages listed in this file when you install a package that has it. This ensures that a Perl package can find its dependencies. 

[var]``buildPerlPackage`` is built on top of [var]``stdenv``, so everything can be customised in the usual way.
For instance, the `BerkeleyDB` module has a [var]``preConfigure`` hook to generate a configuration file used by [path]``Makefile.PL``
: 
[source]
----

{ buildPerlPackage, fetchurl, db }:

buildPerlPackage rec {
  name = "BerkeleyDB-0.36";

  src = fetchurl {
    url = "mirror://cpan/authors/id/P/PM/PMQS/${name}.tar.gz";
    sha256 = "07xf50riarb60l1h6m2dqmql8q5dij619712fsgw7ach04d8g3z1";
  };

  preConfigure = ''
    echo "LIB = ${db.out}/lib" > config.in
    echo "INCLUDE = ${db.dev}/include" >> config.in
  '';
}
----

Dependencies on other Perl packages can be specified in the [var]``buildInputs`` and [var]``propagatedBuildInputs`` attributes.
If something is exclusively a build-time dependency, use [var]``buildInputs``; if it`'s (also) a runtime dependency, use [var]``propagatedBuildInputs``.
For instance, this builds a Perl module that has runtime dependencies on a bunch of other modules: 
[source]
----

ClassC3Componentised = buildPerlPackage rec {
  name = "Class-C3-Componentised-1.0004";
  src = fetchurl {
    url = "mirror://cpan/authors/id/A/AS/ASH/${name}.tar.gz";
    sha256 = "0xql73jkcdbq4q9m0b0rnca6nrlvf5hyzy8is0crdk65bynvs8q1";
  };
  propagatedBuildInputs = [
    ClassC3 ClassInspector TestException MROCompat
  ];
};
----

On Darwin, if a script has too many `-I[replaceable]``dir``` flags in its first line (its "`shebang line`"), it will not run.
This can be worked around by calling the `shortenPerlShebang` function from the `postInstall` phase: 
[source]
----

{ stdenv, buildPerlPackage, fetchurl, shortenPerlShebang }:

ImageExifTool = buildPerlPackage {
  pname = "Image-ExifTool";
  version = "11.50";

  src = fetchurl {
    url = "https://www.sno.phy.queensu.ca/~phil/exiftool/Image-ExifTool-11.50.tar.gz";
    sha256 = "0d8v48y94z8maxkmw1rv7v9m0jg2dc8xbp581njb6yhr7abwqdv3";
  };

  buildInputs = stdenv.lib.optional stdenv.isDarwin shortenPerlShebang;
  postInstall = stdenv.lib.optional stdenv.isDarwin ''
    shortenPerlShebang $out/bin/exiftool
  '';
};
----

This will remove the `-I` flags from the shebang line, rewrite them in the `use lib` form, and put them on the next line instead.
This function can be given any number of Perl scripts as arguments; it will modify them in-place. 

[[_ssec_generation_from_cpan]]
== Generation from CPAN


Nix expressions for Perl packages can be generated (almost) automatically from CPAN.
This is done by the program [command]``nix-generate-from-cpan``, which can be installed as follows: 

----

$ nix-env -i nix-generate-from-cpan
----


This program takes a Perl module name, looks it up on CPAN, fetches and unpacks the corresponding package, and prints a Nix expression on standard output.
For example: 
----

$ nix-generate-from-cpan XML::Simple
  XMLSimple = buildPerlPackage rec {
    name = "XML-Simple-2.22";
    src = fetchurl {
      url = "mirror://cpan/authors/id/G/GR/GRANTM/${name}.tar.gz";
      sha256 = "b9450ef22ea9644ae5d6ada086dc4300fa105be050a2030ebd4efd28c198eb49";
    };
    propagatedBuildInputs = [ XMLNamespaceSupport XMLSAX XMLSAXExpat ];
    meta = {
      description = "An API for simple XML files";
      license = with stdenv.lib.licenses; [ artistic1 gpl1Plus ];
    };
  };
----

The output can be pasted into [path]``pkgs/top-level/perl-packages.nix``
 or wherever else you need it. 

[[_ssec_perl_cross_compilation]]
== Cross-compiling modules


Nixpkgs has experimental support for cross-compiling Perl modules.
In many cases, it will just work out of the box, even for modules with native extensions.
Sometimes, however, the Makefile.PL for a module may (indirectly) import a native module.
In that case, you will need to make a stub for that module that will satisfy the Makefile.PL and install it into [path]``lib/perl5/site_perl/cross_perl/${perl.version}``
.
See the [var]``postInstall`` for [var]``DBI`` for an example. 