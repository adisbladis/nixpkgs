[[_chap_stdenv]]
= The Standard Environment
:doctype: book
:sectnums:
:toc: left
:icons: font
:experimental:
:sourcedir: .
:imagesdir: ./images


The standard build environment in the Nix Packages collection provides an environment for building Unix packages that does a lot of common build tasks automatically.
In fact, for Unix packages that use the standard `$$.$$/configure; make; make install` build interface, you don`'t need to write a build script at all; the standard environment does everything automatically.
If `stdenv` doesn`'t do what you need automatically, you can easily customise or override the various build phases. 

[[_sec_using_stdenv]]
== Using `stdenv`


To build a package with the standard environment, you use the function [var]``stdenv.mkDerivation``, instead of the primitive built-in function [var]``derivation``, e.g. 
[source]
----

stdenv.mkDerivation {
  name = "libfoo-1.2.3";
  src = fetchurl {
    url = http://example.org/libfoo-1.2.3.tar.bz2;
    sha256 = "0x2g1jqygyr5wiwg4ma1nd7w4ydpy82z9gkcv8vh2v8dn3y58v5m";
  };
}
----

([var]``stdenv`` needs to be in scope, so if you write this in a separate Nix expression from [path]``pkgs/all-packages.nix``
, you need to pass it as a function argument.) Specifying a [var]``name`` and a [var]``src`` is the absolute minimum Nix requires.
For convenience, you can also use [var]``pname`` and [var]``version`` attributes and `mkDerivation` will automatically set [var]``name`` to `"${pname}-${version}"` by default.
Since https://github.com/NixOS/rfcs/pull/35[RFC 0035], this is preferred for packages in Nixpkgs, as it allows us to reuse the version easily: 
[source]
----

stdenv.mkDerivation rec {
  pname = "libfoo";
  version = "1.2.3";
  src = fetchurl {
    url = "http://example.org/libfoo-source-${version}.tar.bz2";
    sha256 = "0x2g1jqygyr5wiwg4ma1nd7w4ydpy82z9gkcv8vh2v8dn3y58v5m";
  };
}
----

Many packages have dependencies that are not provided in the standard environment.
It`'s usually sufficient to specify those dependencies in the [var]``buildInputs`` attribute: 
[source]
----

stdenv.mkDerivation {
  name = "libfoo-1.2.3";
  ...
  buildInputs = [libbar perl ncurses];
}
----

This attribute ensures that the [path]``bin``
 subdirectories of these packages appear in the [var]``PATH`` environment variable during the build, that their [path]``include``
 subdirectories are searched by the C compiler, and so on.
(See <<_ssec_setup_hooks>> for details.) 

Often it is necessary to override or modify some aspect of the build.
To make this easier, the standard environment breaks the package build into a number of __phases__, all of which can be overridden or modified individually: unpacking the sources, applying patches, configuring, building, and installing.
(There are some others; see <<_sec_stdenv_phases>>.) For instance, a package that doesn`'t supply a makefile but instead has to be compiled "`manually`" could be handled like this: 
[source]
----

stdenv.mkDerivation {
  name = "fnord-4.5";
  ...
  buildPhase = ''
    gcc foo.c -o foo
  '';
  installPhase = ''
    mkdir -p $out/bin
    cp foo $out/bin
  '';
}
----

(Note the use of ``''``-style string literals, which are very convenient for large multi-line script fragments because they don`'t need escaping of `"` and ``\``, and because indentation is intelligently removed.) 

There are many other attributes to customise the build.
These are listed in <<_ssec_stdenv_attributes>>. 

While the standard environment provides a generic builder, you can still supply your own build script: 
[source]
----

stdenv.mkDerivation {
  name = "libfoo-1.2.3";
  ...
  builder = ./builder.sh;
}
----

where the builder can do anything it wants, but typically starts with 
[source]
----

source $stdenv/setup
----

to let `stdenv` set up the environment (e.g., process the [var]``buildInputs``). If you want, you can still use ``stdenv```'s generic builder: 
[source]
----

source $stdenv/setup

buildPhase() {
  echo "... this is my custom build phase ..."
  gcc foo.c -o foo
}

installPhase() {
  mkdir -p $out/bin
  cp foo $out/bin
}

genericBuild
----

[[_sec_tools_of_stdenv]]
== Tools provided by `stdenv`


The standard environment provides the following packages: 

* The GNU C Compiler, configured with C and C++ support. 
* GNU coreutils (contains a few dozen standard Unix commands). 
* GNU findutils (contains [command]``find``). 
* GNU diffutils (contains [command]``diff``, [command]``cmp``). 
* GNU [command]``sed``. 
* GNU [command]``grep``. 
* GNU [command]``awk``. 
* GNU [command]``tar``. 
* [command]``gzip``, [command]``bzip2`` and [command]``xz``. 
* GNU Make. It has been patched to provide "`nested`" output that can be fed into the [command]``nix-log2xml`` command and [command]``log2html`` stylesheet to create a structured, readable output of the build steps performed by Make. 
* Bash. This is the shell used for all builders in the Nix Packages collection. Not using [command]``/bin/sh`` removes a large source of portability problems. 
* The [command]``patch`` command. 

On Linux, `stdenv` also includes the [command]``patchelf`` utility. 

[[_ssec_stdenv_dependencies]]
== Specifying dependencies


As described in the Nix manual, almost any [path]``*.drv``
 store path in a derivation's attribute set will induce a dependency on that derivation. [var]``mkDerivation``, however, takes a few attributes intended to, between them, include all the dependencies of a package.
This is done both for structure and consistency, but also so that certain other setup can take place.
For example, certain dependencies need their bin directories added to the [var]``PATH``.
That is built-in, but other setup is done via a pluggable mechanism that works in conjunction with these dependency attributes.
See <<_ssec_setup_hooks>> for details. 

Dependencies can be broken down along three axes: their host and target platforms relative to the new derivation's, and whether they are propagated.
The platform distinctions are motivated by cross compilation; see <<_chap_cross>> for exactly what each platform means. footnote:[The build platform is ignored because it is a mere implementation detail of the package satisfying the dependency: As a general programming principle, dependencies are always specified as interfaces, not concrete implementation.]
 But even if one is not cross compiling, the platforms imply whether or not the dependency is needed at run-time or build-time, a concept that makes perfect sense outside of cross compilation.
By default, the run-time/build-time distinction is just a hint for mental clarity, but with [var]``strictDeps`` set it is mostly enforced even in the native case. 

The extension of [var]``PATH`` with dependencies, alluded to above, proceeds according to the relative platforms alone.
The process is carried out only for dependencies whose host platform matches the new derivation's build platform i.e.
dependencies which run on the platform where the new derivation will be built. footnote:[Currently, this means for native builds all dependencies are put on the PATH. But in the future that may not be the case for sake of matching cross: the platforms would be assumed to be unique for native and cross builds alike, so only the depsBuild* and nativeBuildInputs would be added to the PATH.]
 For each dependency [replaceable]``dep`` of those dependencies, [path]``dep/bin``
, if present, is added to the [var]``PATH`` environment variable. 

The dependency is propagated when it forces some of its other-transitive (non-immediate) downstream dependencies to also take it on as an immediate dependency.
Nix itself already takes a package's transitive dependencies into account, but this propagation ensures nixpkgs-specific infrastructure like setup hooks (mentioned above) also are run as if the propagated dependency. 

It is important to note that dependencies are not necessarily propagated as the same sort of dependency that they were before, but rather as the corresponding sort so that the platform rules still line up.
The exact rules for dependency propagation can be given by assigning to each dependency two integers based one how its host and target platforms are offset from the depending derivation's platforms.
Those offsets are given below in the descriptions of each dependency list attribute.
Algorithmically, we traverse propagated inputs, accumulating every propagated dependency's propagated dependencies and adjusting them to account for the "shift in perspective" described by the current dependency's platform offsets.
This results in sort a transitive closure of the dependency relation, with the offsets being approximately summed when two dependency links are combined.
We also prune transitive dependencies whose combined offsets go out-of-bounds, which can be viewed as a filter over that transitive closure removing dependencies that are blatantly absurd. 

We can define the process precisely with https://en.wikipedia.org/wiki/Natural_deduction[Natural Deduction] using the inference rules.
This probably seems a bit obtuse, but so is the bash code that actually implements it! footnote:[The findInputs function, currently residing in pkgs/stdenv/generic/setup.sh, implements the propagation logic.]
 They're confusing in very different ways so... hopefully if something doesn't make sense in one presentation, it will in the other! 
[source]
----

let mapOffset(h, t, i) = i + (if i <= 0 then h else t - 1)

propagated-dep(h0, t0, A, B)
propagated-dep(h1, t1, B, C)
h0 + h1 in {-1, 0, 1}
h0 + t1 in {-1, 0, 1}
-------------------------------------- Transitive property
propagated-dep(mapOffset(h0, t0, h1),
               mapOffset(h0, t0, t1),
               A, C)
----
[source]
----

let mapOffset(h, t, i) = i + (if i <= 0 then h else t - 1)

dep(h0, _, A, B)
propagated-dep(h1, t1, B, C)
h0 + h1 in {-1, 0, 1}
h0 + t1 in {-1, 0, -1}
----------------------------- Take immediate dependencies' propagated dependencies
propagated-dep(mapOffset(h0, t0, h1),
               mapOffset(h0, t0, t1),
               A, C)
----
[source]
----

propagated-dep(h, t, A, B)
----------------------------- Propagated dependencies count as dependencies
dep(h, t, A, B)
----

Some explanation of this monstrosity is in order.
In the common case, the target offset of a dependency is the successor to the target offset: ``t = h + 1``.
That means that: 
[source]
----

let f(h, t, i) = i + (if i <= 0 then h else t - 1)
let f(h, h + 1, i) = i + (if i <= 0 then h else (h + 1) - 1)
let f(h, h + 1, i) = i + (if i <= 0 then h else h)
let f(h, h + 1, i) = i + h
----

This is where "sum-like" comes in from above: We can just sum all of the host offsets to get the host offset of the transitive dependency.
The target offset is the transitive dependency is simply the host offset + 1, just as it was with the dependencies composed to make this transitive one; it can be ignored as it doesn't add any new information. 

Because of the bounds checks, the uncommon cases are `h = t` and ``h + 2 = t``.
In the former case, the motivation for `mapOffset` is that since its host and target platforms are the same, no transitive dependency of it should be able to "discover" an offset greater than its reduced target offsets. `mapOffset` effectively "squashes" all its transitive dependencies' offsets so that none will ever be greater than the target offset of the original `h = t` package.
In the other case, `h + 1` is skipped over between the host and target offsets.
Instead of squashing the offsets, we need to "rip" them apart so no transitive dependencies' offset is that one. 

Overall, the unifying theme here is that propagation shouldn't be introducing transitive dependencies involving platforms the depending package is unaware of.
[One can imagine the dependending package asking for dependencies with the platforms it knows about; other platforms it doesn't know how to ask for.
The platform description in that scenario is a kind of unforagable capability.] The offset bounds checking and definition of `mapOffset` together ensure that this is the case.
Discovering a new offset is discovering a new platform, and since those platforms weren't in the derivation "spec" of the needing package, they cannot be relevant.
From a capability perspective, we can imagine that the host and target platforms of a package are the capabilities a package requires, and the depending package must provide the capability to the dependency. 

.Variables specifying dependencies
[var]``depsBuildBuild``::
A list of dependencies whose host and target platforms are the new derivation's build platform.
This means a `-1` host and `-1` target offset from the new derivation's platforms.
These are programs and libraries used at build time that produce programs and libraries also used at build time.
If the dependency doesn't care about the target platform (i.e.
isn't a compiler or similar tool), put it in [var]``nativeBuildInputs`` instead.
The most common use of this ``buildPackages.stdenv.cc``, the default C compiler for this role.
That example crops up more than one might think in old commonly used C libraries. 
+
Since these packages are able to be run at build-time, they are always added to the [var]``PATH``, as described above.
But since these packages are only guaranteed to be able to run then, they shouldn't persist as run-time dependencies.
This isn't currently enforced, but could be in the future. 

[var]``nativeBuildInputs``::
A list of dependencies whose host platform is the new derivation's build platform, and target platform is the new derivation's host platform.
This means a `-1` host offset and `0` target offset from the new derivation's platforms.
These are programs and libraries used at build-time that, if they are a compiler or similar tool, produce code to run at run-time--i.e.
tools used to build the new derivation.
If the dependency doesn't care about the target platform (i.e.
isn't a compiler or similar tool), put it here, rather than in [var]``depsBuildBuild`` or [var]``depsBuildTarget``.
This could be called [var]``depsBuildHost`` but [var]``nativeBuildInputs`` is used for historical continuity. 
+
Since these packages are able to be run at build-time, they are added to the [var]``PATH``, as described above.
But since these packages are only guaranteed to be able to run then, they shouldn't persist as run-time dependencies.
This isn't currently enforced, but could be in the future. 

[var]``depsBuildTarget``::
A list of dependencies whose host platform is the new derivation's build platform, and target platform is the new derivation's target platform.
This means a `-1` host offset and `1` target offset from the new derivation's platforms.
These are programs used at build time that produce code to run with code produced by the depending package.
Most commonly, these are tools used to build the runtime or standard library that the currently-being-built compiler will inject into any code it compiles.
In many cases, the currently-being-built-compiler is itself employed for that task, but when that compiler won't run (i.e.
its build and host platform differ) this is not possible.
Other times, the compiler relies on some other tool, like binutils, that is always built separately so that the dependency is unconditional. 
+
This is a somewhat confusing concept to wrap one`'s head around, and for good reason.
As the only dependency type where the platform offsets are not adjacent integers, it requires thinking of a bootstrapping stage _two_ away from the current one.
It and its use-case go hand in hand and are both considered poor form: try to not need this sort of dependency, and try to avoid building standard libraries and runtimes in the same derivation as the compiler produces code using them.
Instead strive to build those like a normal library, using the newly-built compiler just as a normal library would.
In short, do not use this attribute unless you are packaging a compiler and are sure it is needed. 
+
Since these packages are able to run at build time, they are added to the [var]``PATH``, as described above.
But since these packages are only guaranteed to be able to run then, they shouldn't persist as run-time dependencies.
This isn't currently enforced, but could be in the future. 

[var]``depsHostHost``::
A list of dependencies whose host and target platforms match the new derivation's host platform.
This means a `0` host offset and `0` target offset from the new derivation's host platform.
These are packages used at run-time to generate code also used at run-time.
In practice, this would usually be tools used by compilers for macros or a metaprogramming system, or libraries used by the macros or metaprogramming code itself.
It's always preferable to use a [var]``depsBuildBuild`` dependency in the derivation being built over a [var]``depsHostHost`` on the tool doing the building for this purpose. 

[var]``buildInputs``::
A list of dependencies whose host platform and target platform match the new derivation's.
This means a `0` host offset and a `1` target offset from the new derivation's host platform.
This would be called [var]``depsHostTarget`` but for historical continuity.
If the dependency doesn't care about the target platform (i.e.
isn't a compiler or similar tool), put it here, rather than in [var]``depsBuildBuild``. 
+
These are often programs and libraries used by the new derivation at __run__-time, but that isn't always the case.
For example, the machine code in a statically-linked library is only used at run-time, but the derivation containing the library is only needed at build-time.
Even in the dynamic case, the library may also be needed at build-time to appease the linker. 

[var]``depsTargetTarget``::
A list of dependencies whose host platform matches the new derivation's target platform.
This means a `1` offset from the new derivation's platforms.
These are packages that run on the target platform, e.g.
the standard library or run-time deps of standard library that a compiler insists on knowing about.
It's poor form in almost all cases for a package to depend on another from a future stage [future stage corresponding to positive offset]. Do not use this attribute unless you are packaging a compiler and are sure it is needed. 

[var]``depsBuildBuildPropagated``::
The propagated equivalent of [var]``depsBuildBuild``.
This perhaps never ought to be used, but it is included for consistency [see below for the others]. 

[var]``propagatedNativeBuildInputs``::
The propagated equivalent of [var]``nativeBuildInputs``.
This would be called [var]``depsBuildHostPropagated`` but for historical continuity.
For example, if package [var]``Y`` has ``propagatedNativeBuildInputs = [X]``, and package [var]``Z`` has ``buildInputs = [Y]``, then package [var]``Z`` will be built as if it included package [var]``X`` in its [var]``nativeBuildInputs``.
If instead, package [var]``Z`` has ``nativeBuildInputs = [Y]``, then [var]``Z`` will be built as if it included [var]``X`` in the [var]``depsBuildBuild`` of package [var]``Z``, because of the sum of the two `-1` host offsets. 

[var]``depsBuildTargetPropagated``::
The propagated equivalent of [var]``depsBuildTarget``.
This is prefixed for the same reason of alerting potential users. 

[var]``depsHostHostPropagated``::
The propagated equivalent of [var]``depsHostHost``. 

[var]``propagatedBuildInputs``::
The propagated equivalent of [var]``buildInputs``.
This would be called [var]``depsHostTargetPropagated`` but for historical continuity. 

[var]``depsTargetTargetPropagated``::
The propagated equivalent of [var]``depsTargetTarget``.
This is prefixed for the same reason of alerting potential users. 


[[_ssec_stdenv_attributes]]
== Attributes

.Variables affecting `stdenv` initialisation
[var]``NIX_DEBUG``::
A natural number indicating how much information to log.
If set to 1 or higher, `stdenv` will print moderate debugging information during the build.
In particular, the [command]``gcc`` and [command]``ld`` wrapper scripts will print out the complete command line passed to the wrapped tools.
If set to 6 or higher, the `stdenv` setup script will be run with `set -x` tracing.
If set to 7 or higher, the [command]``gcc`` and [command]``ld`` wrapper scripts will also be run with `set -x` tracing. 


.Attributes affecting build properties
[var]``enableParallelBuilding``::
If set to ``true``, `stdenv` will pass specific flags to `make` and other build tools to enable parallel building with up to `build-cores` workers. 
+
Unless set to ``false``, some build systems with good support for parallel building including ``cmake``, ``meson``, and `qmake` will set it to ``true``. 


.Special variables
[var]``passthru``::
This is an attribute set which can be filled with arbitrary values.
For example: 
+
[source]
----

passthru = {
  foo = "bar";
  baz = {
    value1 = 4;
    value2 = 5;
  };
}
----
+
Values inside it are not passed to the builder, so you can change them without triggering a rebuild.
However, they can be accessed outside of a derivation directly, as if they were set inside a derivation itself, e.g. ``hello.baz.value1``.
We don't specify any usage or schema of `passthru` - it is meant for values that would be useful outside the derivation in other parts of a Nix expression (e.g.
in other derivations). An example would be to convey some specific dependency of your derivation which contains a program with plugins support.
Later, others who make derivations with plugins can use passed-through dependency to ensure that their plugin would be binary-compatible with built program. 

[[_var_passthru_updatescript]]
[var]``passthru.updateScript``::
A script to be run by [path]``maintainers/scripts/update.nix``
when the package is matched.
It needs to be an executable file, either on the file system: 
+
[source]
----

passthru.updateScript = ./update.sh;
----

or inside the expression itself: 
[source]
----

passthru.updateScript = writeScript "update-zoom-us" ''
  #!/usr/bin/env nix-shell
  #!nix-shell -i bash -p curl pcre common-updater-scripts

  set -eu -o pipefail

  version="$(curl -sI https://zoom.us/client/latest/zoom_x86_64.tar.xz | grep -Fi 'Location:' | pcregrep -o1 '/(([0-9]\.?)+)/')"
  update-source-version zoom-us "$version"
'';
----

The attribute can also contain a list, a script followed by arguments to be passed to it: 
[source]
----

passthru.updateScript = [ ../../update.sh pname "--requested-release=unstable" ];
----
+
The script will be usually run from the root of the Nixpkgs repository but you should not rely on that.
Also note that the update scripts will be run in parallel by default; you should avoid running [command]``git commit`` or any other commands that cannot handle that. 
+
For information about how to run the updates, execute [command]``nix-shell maintainers/scripts/update.nix``. 


[[_sec_stdenv_phases]]
== Phases


The generic builder has a number of __phases__.
Package builds are split into phases to make it easier to override specific parts of the build (e.g., unpacking the sources or installing the binaries). Furthermore, it allows a nicer presentation of build logs in the Nix build farm. 

Each phase can be overridden in its entirety either by setting the environment variable [var]``[replaceable]``name``Phase`` to a string containing some shell commands to be executed, or by redefining the shell function [var]``[replaceable]``name``Phase``.
The former is convenient to override a phase from the derivation, while the latter is convenient from a build script.
However, typically one only wants to _add_ some commands to a phase, e.g.
by defining `postInstall` or ``preFixup``, as skipping some of the default actions may have unexpected consequences.
The default script for each phase is defined in the file [path]``pkgs/stdenv/generic/setup.sh``
. 

[[_ssec_controlling_phases]]
=== Controlling phases


There are a number of variables that control what phases are executed and in what order: 

.Variables affecting phase control
[var]``phases``::
Specifies the phases.
You can change the order in which phases are executed, or add new phases, by setting this variable.
If it`'s not set, the default value is used, which is ``$prePhases unpackPhase patchPhase $preConfigurePhases configurePhase $preBuildPhases buildPhase checkPhase $preInstallPhases installPhase fixupPhase installCheckPhase $preDistPhases distPhase $postPhases``. 
+
Usually, if you just want to add a few phases, it`'s more convenient to set one of the variables below (such as [var]``preInstallPhases``), as you then don`'t specify all the normal phases. 

[var]``prePhases``::
Additional phases executed before any of the default phases. 

[var]``preConfigurePhases``::
Additional phases executed just before the configure phase. 

[var]``preBuildPhases``::
Additional phases executed just before the build phase. 

[var]``preInstallPhases``::
Additional phases executed just before the install phase. 

[var]``preFixupPhases``::
Additional phases executed just before the fixup phase. 

[var]``preDistPhases``::
Additional phases executed just before the distribution phase. 

[var]``postPhases``::
Additional phases executed after any of the default phases. 


[[_ssec_unpack_phase]]
=== The unpack phase


The unpack phase is responsible for unpacking the source code of the package.
The default implementation of `unpackPhase` unpacks the source files listed in the [var]``src`` environment variable to the current directory.
It supports the following files by default: 
 Tar files::
These can optionally be compressed using [command]``gzip`` ([path]``.tar.gz``
, [path]``.tgz``
or [path]``.tar.Z``
), [command]``bzip2`` ([path]``.tar.bz2``
, [path]``.tbz2``
or [path]``.tbz``
) or [command]``xz`` ([path]``.tar.xz``
, [path]``.tar.lzma``
or [path]``.txz``
). 
 Zip files::
Zip files are unpacked using [command]``unzip``.
However, [command]``unzip`` is not in the standard environment, so you should add it to [var]``nativeBuildInputs`` yourself. 
 Directories in the Nix store::
These are simply copied to the current directory.
The hash part of the file name is stripped, e.g. [path]``/nix/store/1wydxgby13cz...-my-sources``
would be copied to [path]``my-sources``
. 

Additional file types can be supported by setting the [var]``unpackCmd`` variable (see below). 



.Variables controlling the unpack phase
[var]``srcs`` / [var]``src``::
The list of source files or directories to be unpacked or copied.
One of these must be set. 

[var]``sourceRoot``::
After running ``unpackPhase``, the generic builder changes the current directory to the directory created by unpacking the sources.
If there are multiple source directories, you should set [var]``sourceRoot`` to the name of the intended directory. 

[var]``setSourceRoot``::
Alternatively to setting [var]``sourceRoot``, you can set [var]``setSourceRoot`` to a shell command to be evaluated by the unpack phase after the sources have been unpacked.
This command must set [var]``sourceRoot``. 

[var]``preUnpack``::
Hook executed at the start of the unpack phase. 

[var]``postUnpack``::
Hook executed at the end of the unpack phase. 

[var]``dontUnpack``::
Set to true to skip the unpack phase. 

[var]``dontMakeSourcesWritable``::
If set to ``1``, the unpacked sources are _not_ made writable.
By default, they are made writable to prevent problems with read-only sources.
For example, copied store directories would be read-only without this. 

[var]``unpackCmd``::
The unpack phase evaluates the string `$unpackCmd` for any unrecognised file.
The path to the current source file is contained in the [var]``curSrc`` variable. 


[[_ssec_patch_phase]]
=== The patch phase


The patch phase applies the list of patches defined in the [var]``patches`` variable. 

.Variables controlling the patch phase
[var]``patches``::
The list of patches.
They must be in the format accepted by the [command]``patch`` command, and may optionally be compressed using [command]``gzip`` ([path]``.gz``
), [command]``bzip2`` ([path]``.bz2``
) or [command]``xz`` ([path]``.xz``
). 

[var]``patchFlags``::
Flags to be passed to [command]``patch``.
If not set, the argument [option]``-p1`` is used, which causes the leading directory component to be stripped from the file names in each patch. 

[var]``prePatch``::
Hook executed at the start of the patch phase. 

[var]``postPatch``::
Hook executed at the end of the patch phase. 


[[_ssec_configure_phase]]
=== The configure phase


The configure phase prepares the source tree for building.
The default `configurePhase` runs [path]``./configure``
 (typically an Autoconf-generated script) if it exists. 

.Variables controlling the configure phase
[var]``configureScript``::
The name of the configure script.
It defaults to [path]``./configure``
if it exists; otherwise, the configure phase is skipped.
This can actually be a command (like ``perl ./Configure.pl``). 

[var]``configureFlags``::
A list of strings passed as additional arguments to the configure script. 

[var]``dontConfigure``::
Set to true to skip the configure phase. 

[var]``configureFlagsArray``::
A shell array containing additional arguments passed to the configure script.
You must use this instead of [var]``configureFlags`` if the arguments contain spaces. 

[var]``dontAddPrefix``::
By default, the flag `--prefix=$prefix` is added to the configure flags.
If this is undesirable, set this variable to true. 

[var]``prefix``::
The prefix under which the package must be installed, passed via the [option]``--prefix`` option to the configure script.
It defaults to [option]``$out``. 

[var]``prefixKey``::
The key to use when specifying the prefix.
By default, this is set to [option]``--prefix=`` as that is used by the majority of packages. 

[var]``dontAddDisableDepTrack``::
By default, the flag `--disable-dependency-tracking` is added to the configure flags to speed up Automake-based builds.
If this is undesirable, set this variable to true. 

[var]``dontFixLibtool``::
By default, the configure phase applies some special hackery to all files called [path]``ltmain.sh``
before running the configure script in order to improve the purity of Libtool-based packages footnote:[It clears the sys_lib_*search_path variables in the Libtool script to prevent Libtool from using libraries in /usr/lib and such.]
. If this is undesirable, set this variable to true. 

[var]``dontDisableStatic``::
By default, when the configure script has [option]``--enable-static``, the option [option]``--disable-static`` is added to the configure flags. 
+
If this is undesirable, set this variable to true. 

[var]``configurePlatforms``::
By default, when cross compiling, the configure script has [option]``--build=...`` and [option]``--host=...`` passed.
Packages can instead pass `[ "build" "host" "target" ]` or a subset to control exactly which platform flags are passed.
Compilers and other tools can use this to also pass the target platform. footnote:[Eventually these will be passed building natively as well, to improve determinism: build-time guessing, as is done today, is a risk of impurity.]

[var]``preConfigure``::
Hook executed at the start of the configure phase. 

[var]``postConfigure``::
Hook executed at the end of the configure phase. 


[[_build_phase]]
=== The build phase


The build phase is responsible for actually building the package (e.g.
compiling it). The default `buildPhase` simply calls [command]``make`` if a file named [path]``Makefile``
, [path]``makefile``
 or [path]``GNUmakefile``
 exists in the current directory (or the [var]``makefile`` is explicitly set); otherwise it does nothing. 

.Variables controlling the build phase
[var]``dontBuild``::
Set to true to skip the build phase. 

[var]``makefile``::
The file name of the Makefile. 

[var]``makeFlags``::
A list of strings passed as additional flags to [command]``make``.
These flags are also used by the default install and check phase.
For setting make flags specific to the build phase, use [var]``buildFlags`` (see below). 
+
[source]
----

makeFlags = [ "PREFIX=$(out)" ];
----
NOTE: The flags are quoted in bash, but environment variables can be specified by using the make syntax. 
+



[var]``makeFlagsArray``::
A shell array containing additional arguments passed to [command]``make``.
You must use this instead of [var]``makeFlags`` if the arguments contain spaces, e.g. 
+
[source]
----

preBuild = ''
  makeFlagsArray+=(CFLAGS="-O0 -g" LDFLAGS="-lfoo -lbar")
'';
----

Note that shell arrays cannot be passed through environment variables, so you cannot set [var]``makeFlagsArray`` in a derivation attribute (because those are passed through environment variables): you have to define them in shell code. 

[var]``buildFlags`` / [var]``buildFlagsArray``::
A list of strings passed as additional flags to [command]``make``.
Like [var]``makeFlags`` and [var]``makeFlagsArray``, but only used by the build phase. 

[var]``preBuild``::
Hook executed at the start of the build phase. 

[var]``postBuild``::
Hook executed at the end of the build phase. 


You can set flags for [command]``make`` through the [var]``makeFlags`` variable. 

Before and after running [command]``make``, the hooks [var]``preBuild`` and [var]``postBuild`` are called, respectively. 

[[_ssec_check_phase]]
=== The check phase


The check phase checks whether the package was built correctly by running its test suite.
The default `checkPhase` calls [command]``make check``, but only if the [var]``doCheck`` variable is enabled. 

.Variables controlling the check phase
[var]``doCheck``::
Controls whether the check phase is executed.
By default it is skipped, but if [var]``doCheck`` is set to true, the check phase is usually executed.
Thus you should set 
+
[source]
----
doCheck = true;
----

in the derivation to enable checks.
The exception is cross compilation.
Cross compiled builds never run tests, no matter how [var]``doCheck`` is set, as the newly-built program won't run on the platform used to build it. 

[var]``makeFlags`` / [var]``makeFlagsArray`` / [var]``makefile``::
See the build phase for details. 

[var]``checkTarget``::
The make target that runs the tests.
Defaults to ``check``. 

[var]``checkFlags`` / [var]``checkFlagsArray``::
A list of strings passed as additional flags to [command]``make``.
Like [var]``makeFlags`` and [var]``makeFlagsArray``, but only used by the check phase. 

[var]``checkInputs``::
A list of dependencies used by the phase.
This gets included in [var]``nativeBuildInputs`` when [var]``doCheck`` is set. 

[var]``preCheck``::
Hook executed at the start of the check phase. 

[var]``postCheck``::
Hook executed at the end of the check phase. 


[[_ssec_install_phase]]
=== The install phase


The install phase is responsible for installing the package in the Nix store under [var]``out``.
The default `installPhase` creates the directory `$out` and calls [command]``make install``. 

.Variables controlling the install phase
[var]``dontInstall``::
Set to true to skip the install phase. 

[var]``makeFlags`` / [var]``makeFlagsArray`` / [var]``makefile``::
See the build phase for details. 

[var]``installTargets``::
The make targets that perform the installation.
Defaults to ``install``.
Example: 
+
[source]
----

installTargets = "install-bin install-doc";
----

[var]``installFlags`` / [var]``installFlagsArray``::
A list of strings passed as additional flags to [command]``make``.
Like [var]``makeFlags`` and [var]``makeFlagsArray``, but only used by the install phase. 

[var]``preInstall``::
Hook executed at the start of the install phase. 

[var]``postInstall``::
Hook executed at the end of the install phase. 


[[_ssec_fixup_phase]]
=== The fixup phase


The fixup phase performs some (Nix-specific) post-processing actions on the files installed under [path]``$out``
 by the install phase.
The default `fixupPhase` does the following: 

* It moves the [path]``man/`` , [path]``doc/`` and [path]``info/`` subdirectories of [var]``$out`` to [path]``share/`` . 
* It strips libraries and executables of debug information. 
* On Linux, it applies the [command]``patchelf`` command to ELF executables and libraries to remove unused directories from the `RPATH` in order to prevent unnecessary runtime dependencies. 
* It rewrites the interpreter paths of shell scripts to paths found in [var]``PATH``. E.g., [path]``/usr/bin/perl`` will be rewritten to [path]``/nix/store/some-perl/bin/perl`` found in [var]``PATH``. 


.Variables controlling the fixup phase
[var]``dontFixup``::
Set to true to skip the fixup phase. 

[var]``dontStrip``::
If set, libraries and executables are not stripped.
By default, they are. 

[var]``dontStripHost``::
Like [var]``dontStrip``, but only affects the [command]``strip`` command targetting the package's host platform.
Useful when supporting cross compilation, but otherwise feel free to ignore. 

[var]``dontStripTarget``::
Like [var]``dontStrip``, but only affects the [command]``strip`` command targetting the packages' target platform.
Useful when supporting cross compilation, but otherwise feel free to ignore. 

[var]``dontMoveSbin``::
If set, files in [path]``$out/sbin``
are not moved to [path]``$out/bin``
.
By default, they are. 

[var]``stripAllList``::
List of directories to search for libraries and executables from which _all_ symbols should be stripped.
By default, it`'s empty.
Stripping all symbols is risky, since it may remove not just debug symbols but also ELF information necessary for normal execution. 

[var]``stripAllFlags``::
Flags passed to the [command]``strip`` command applied to the files in the directories listed in [var]``stripAllList``.
Defaults to [option]``-s`` (i.e. [option]``--strip-all``). 

[var]``stripDebugList``::
List of directories to search for libraries and executables from which only debugging-related symbols should be stripped.
It defaults to ``lib bin sbin``. 

[var]``stripDebugFlags``::
Flags passed to the [command]``strip`` command applied to the files in the directories listed in [var]``stripDebugList``.
Defaults to [option]``-S`` (i.e. [option]``--strip-debug``). 

[var]``dontPatchELF``::
If set, the [command]``patchelf`` command is not used to remove unnecessary `RPATH` entries.
Only applies to Linux. 

[var]``dontPatchShebangs``::
If set, scripts starting with `\#!` do not have their interpreter paths rewritten to paths in the Nix store. 

[var]``dontPruneLibtoolFiles``::
If set, libtool `$$.$$la` files associated with shared libraries won't have their `dependency_libs` field cleared. 

[var]``forceShare``::
The list of directories that must be moved from [path]``$out``
to [path]``$out/share``
.
Defaults to ``man doc info``. 

[var]``setupHook``::
A package can export a <<_ssec_setup_hooks,setup hook>> by setting this variable.
The setup hook, if defined, is copied to [path]``$out/nix-support/setup-hook``
.
Environment variables are then substituted in it using ``substituteAll``. 

[var]``preFixup``::
Hook executed at the start of the fixup phase. 

[var]``postFixup``::
Hook executed at the end of the fixup phase. 

[[_stdenv_separatedebuginfo]]
[var]``separateDebugInfo``::
If set to ``true``, the standard environment will enable debug information in C/C++ builds.
After installation, the debug information will be separated from the executables and stored in the output named ``debug``.
(This output is enabled automatically; you don`'t need to set the [var]``outputs`` attribute explicitly.) To be precise, the debug information is stored in [path]``debug/lib/debug/.build-id/XX/YYYY…``
, where [replaceable]``XXYYYY...`` is the [replaceable]``build ID`` of the binary -- a SHA-1 hash of the contents of the binary.
Debuggers like GDB use the build ID to look up the separated debug information. 
+
For example, with GDB, you can add 
+
[source]
----

set debug-file-directory ~/.nix-profile/lib/debug
----

to [path]``~/.gdbinit``
.
GDB will then be able to find debug information installed via ``nix-env -i``. 


[[_ssec_installcheck_phase]]
=== The installCheck phase


The installCheck phase checks whether the package was installed correctly by running its test suite against the installed directories.
The default `installCheck` calls [command]``make installcheck``. 

.Variables controlling the installCheck phase
[var]``doInstallCheck``::
Controls whether the installCheck phase is executed.
By default it is skipped, but if [var]``doInstallCheck`` is set to true, the installCheck phase is usually executed.
Thus you should set 
+
[source]
----
doInstallCheck = true;
----

in the derivation to enable install checks.
The exception is cross compilation.
Cross compiled builds never run tests, no matter how [var]``doInstallCheck`` is set, as the newly-built program won't run on the platform used to build it. 

[var]``installCheckTarget``::
The make target that runs the install tests.
Defaults to ``installcheck``. 

[var]``installCheckFlags`` / [var]``installCheckFlagsArray``::
A list of strings passed as additional flags to [command]``make``.
Like [var]``makeFlags`` and [var]``makeFlagsArray``, but only used by the installCheck phase. 

[var]``installCheckInputs``::
A list of dependencies used by the phase.
This gets included in [var]``nativeBuildInputs`` when [var]``doInstallCheck`` is set. 

[var]``preInstallCheck``::
Hook executed at the start of the installCheck phase. 

[var]``postInstallCheck``::
Hook executed at the end of the installCheck phase. 


[[_ssec_distribution_phase]]
=== The distribution phase


The distribution phase is intended to produce a source distribution of the package.
The default `distPhase` first calls [command]``make dist``, then it copies the resulting source tarballs to [path]``$out/tarballs/``
.
This phase is only executed if the attribute [var]``doDist`` is set. 

.Variables controlling the distribution phase
[var]``distTarget``::
The make target that produces the distribution.
Defaults to ``dist``. 

[var]``distFlags`` / [var]``distFlagsArray``::
Additional flags passed to [command]``make``. 

[var]``tarballs``::
The names of the source distribution files to be copied to [path]``$out/tarballs/``
.
It can contain shell wildcards.
The default is [path]``*.tar.gz``
. 

[var]``dontCopyDist``::
If set, no files are copied to [path]``$out/tarballs/``
. 

[var]``preDist``::
Hook executed at the start of the distribution phase. 

[var]``postDist``::
Hook executed at the end of the distribution phase. 


[[_ssec_stdenv_functions]]
== Shell functions


The standard environment provides a number of useful functions. 

[[_fun_makewrapper]]
`makeWrapper`[replaceable]``executable``[replaceable]``wrapperfile``[replaceable]``args``::
Constructs a wrapper for a program with various possible arguments.
For example: 
+
[source]
----

# adds `FOOBAR=baz` to `$out/bin/foo`’s environment
makeWrapper $out/bin/foo $wrapperfile --set FOOBAR baz

# prefixes the binary paths of `hello` and `git`
# Be advised that paths often should be patched in directly
# (via string replacements or in `configurePhase`).
makeWrapper $out/bin/foo $wrapperfile --prefix PATH : ${lib.makeBinPath [ hello git ]}
----

There`'s many more kinds of arguments, they are documented in ``nixpkgs/pkgs/build-support/setup-hooks/make-wrapper.sh``. 
+
`wrapProgram` is a convenience function you probably want to use most of the time. 

[[_fun_substitute]]
`substitute`[replaceable]``infile``[replaceable]``outfile``[replaceable]``subs``::
Performs string substitution on the contents of [replaceable]``infile``, writing the result to [replaceable]``outfile``.
The substitutions in [replaceable]``subs`` are of the following form: 
+

[option]``--replace``[replaceable]``s1``[replaceable]``s2``:::
Replace every occurrence of the string [replaceable]``s1`` by [replaceable]``s2``. 

[option]``--subst-var``[replaceable]``varName``:::
Replace every occurrence of `@[replaceable]``varName``@` by the contents of the environment variable [replaceable]``varName``.
This is useful for generating files from templates, using `@[replaceable]``$$...$$``@` in the template as placeholders. 

[option]``--subst-var-by``[replaceable]``varName``[replaceable]``s``:::
Replace every occurrence of `@[replaceable]``varName``@` by the string [replaceable]``s``. 

+
Example: 
+
[source]
----

substitute ./foo.in ./foo.out \
    --replace /usr/bin/bar $bar/bin/bar \
    --replace "a string containing spaces" "some other text" \
    --subst-var someVar
----
+
`substitute` is implemented using the [command]``replace`` command.
Unlike with the [command]``sed`` command, you don`'t have to worry about escaping special characters.
It supports performing substitutions on binary files (such as executables), though there you`'ll probably want to make sure that the replacement string is as long as the replaced string. 

[[_fun_substituteinplace]]
`substituteInPlace`[replaceable]``file``[replaceable]``subs``::
Like ``substitute``, but performs the substitutions in place on the file [replaceable]``file``. 

[[_fun_substituteall]]
`substituteAll`[replaceable]``infile``[replaceable]``outfile``::
Replaces every occurrence of ``@[replaceable]``varName``@``, where [replaceable]``varName`` is any environment variable, in [replaceable]``infile``, writing the result to [replaceable]``outfile``.
For instance, if [replaceable]``infile`` has the contents 
+
[source]
----

#! @bash@/bin/sh
PATH=@coreutils@/bin
echo @foo@
----

and the environment contains `bash=/nix/store/bmwp0q28cf21...-bash-3.2-p39` and ``coreutils=/nix/store/68afga4khv0w...-coreutils-6.12``, but does not contain the variable [var]``foo``, then the output will be 
[source]
----

#! /nix/store/bmwp0q28cf21...-bash-3.2-p39/bin/sh
PATH=/nix/store/68afga4khv0w...-coreutils-6.12/bin
echo @foo@
----

That is, no substitution is performed for undefined variables. 
+
Environment variables that start with an uppercase letter or an underscore are filtered out, to prevent global variables (like ``HOME``) or private variables (like ``\__ETC_PROFILE_DONE``) from accidentally getting substituted.
The variables also have to be valid bash "`names`", as defined in the bash manpage (alphanumeric or ``\_``, must not start with a number). 

[[_fun_substituteallinplace]]
`substituteAllInPlace`[replaceable]``file``::
Like ``substituteAll``, but performs the substitutions in place on the file [replaceable]``file``. 

[[_fun_striphash]]
`stripHash`[replaceable]``path``::
Strips the directory and hash part of a store path, outputting the name part to ``stdout``.
For example: 
+
[source]
----

# prints coreutils-8.24
stripHash "/nix/store/9s9r019176g7cvn2nvcw41gsp862y6b4-coreutils-8.24"
----

If you wish to store the result in another variable, then the following idiom may be useful: 
[source]
----

name="/nix/store/9s9r019176g7cvn2nvcw41gsp862y6b4-coreutils-8.24"
someVar=$(stripHash $name)
----

[[_fun_wrapprogram]]
`wrapProgram`[replaceable]``executable``[replaceable]``makeWrapperArgs``::
Convenience function for `makeWrapper` that automatically creates a sane wrapper file.
It takes all the same arguments as ``makeWrapper``, except for ``--argv0``. 
+
It cannot be applied multiple times, since it will overwrite the wrapper file. 


[[_ssec_setup_hooks]]
== Package setup hooks


Nix itself considers a build-time dependency as merely something that should previously be built and accessible at build time--packages themselves are on their own to perform any additional setup.
In most cases, that is fine, and the downstream derivation can deal with its own dependencies.
But for a few common tasks, that would result in almost every package doing the same sort of setup work--depending not on the package itself, but entirely on which dependencies were used. 

In order to alleviate this burden, the [term]_setup hook_
 mechanism was written, where any package can include a shell script that [by convention rather than enforcement by Nix], any downstream reverse-dependency will source as part of its build process.
That allows the downstream dependency to merely specify its dependencies, and lets those dependencies effectively initialize themselves.
No boilerplate mirroring the list of dependencies is needed. 

The setup hook mechanism is a bit of a sledgehammer though: a powerful feature with a broad and indiscriminate area of effect.
The combination of its power and implicit use may be expedient, but isn't without costs.
Nix itself is unchanged, but the spirit of added dependencies being effect-free is violated even if the letter isn't.
For example, if a derivation path is mentioned more than once, Nix itself doesn't care and simply makes sure the dependency derivation is already built just the same--depending is just needing something to exist, and needing is idempotent.
However, a dependency specified twice will have its setup hook run twice, and that could easily change the build environment (though a well-written setup hook will therefore strive to be idempotent so this is in fact not observable). More broadly, setup hooks are anti-modular in that multiple dependencies, whether the same or different, should not interfere and yet their setup hooks may well do so. 

The most typical use of the setup hook is actually to add other hooks which are then run (i.e.
after all the setup hooks) on each dependency.
For example, the C compiler wrapper's setup hook feeds itself flags for each dependency that contains relevant libraries and headers.
This is done by defining a bash function, and appending its name to one of [var]``envBuildBuildHooks``, [var]``envBuildHostHooks``, [var]``envBuildTargetHooks``, [var]``envHostHostHooks``, [var]``envHostTargetHooks``, or [var]``envTargetTargetHooks``.
These 6 bash variables correspond to the 6 sorts of dependencies by platform (there's 12 total but we ignore the propagated/non-propagated axis). 

Packages adding a hook should not hard code a specific hook, but rather choose a variable _relative_ to how they are included.
Returning to the C compiler wrapper example, if the wrapper itself is an `n` dependency, then it only wants to accumulate flags from `n + 1` dependencies, as only those ones match the compiler's target platform.
The [var]``hostOffset`` variable is defined with the current dependency's host offset [var]``targetOffset`` with its target offset, before its setup hook is sourced.
Additionally, since most environment hooks don't care about the target platform, that means the setup hook can append to the right bash array by doing something like 
[source,bash]
----

addEnvHooks "$hostOffset" myBashFunction
----

The _existence_ of setups hooks has long been documented and packages inside Nixpkgs are free to use this mechanism.
Other packages, however, should not rely on these mechanisms not changing between Nixpkgs versions.
Because of the existing issues with this system, there's little benefit from mandating it be stable for any period of time. 

First, let`'s cover some setup hooks that are part of Nixpkgs default stdenv.
This means that they are run for every package built using ``stdenv.mkDerivation``.
Some of these are platform specific, so they may run on Linux but not Darwin or vice-versa. 

`move-docs.sh`::
This setup hook moves any installed documentation to the `/share` subdirectory directory.
This includes the man, doc and info directories.
This is needed for legacy programs that do not know how to use the `share` subdirectory. 

`compress-man-pages.sh`::
This setup hook compresses any man pages that have been installed.
The compression is done using the gzip program.
This helps to reduce the installed size of packages. 

`strip.sh`::
This runs the strip command on installed binaries and libraries.
This removes unnecessary information like debug symbols when they are not needed.
This also helps to reduce the installed size of packages. 

`patch-shebangs.sh`::
This setup hook patches installed scripts to use the full path to the shebang interpreter.
A shebang interpreter is the first commented line of a script telling the operating system which program will run the script (e.g ``\#!/bin/bash``). In Nix, we want an exact path to that interpreter to be used.
This often replaces `/bin/sh` with a path in the Nix store. 

`audit-tmpdir.sh`::
This verifies that no references are left from the install binaries to the directory used to build those binaries.
This ensures that the binaries do not need things outside the Nix store.
This is currently supported in Linux only. 

`multiple-outputs.sh`::
This setup hook adds configure flags that tell packages to install files into any one of the proper outputs listed in ``outputs``.
This behavior can be turned off by setting `setOutputFlags` to false in the derivation environment.
See <<_chap_multiple_output>> for more information. 

`move-sbin.sh`::
This setup hook moves any binaries installed in the sbin subdirectory into bin.
In addition, a link is provided from sbin to bin for compatibility. 

`move-lib64.sh`::
This setup hook moves any libraries installed in the lib64 subdirectory into lib.
In addition, a link is provided from lib64 to lib for compatibility. 

`set-source-date-epoch-to-latest.sh`::
This sets `SOURCE_DATE_EPOCH` to the modification time of the most recent file. 
 Bintools Wrapper::
The Bintools Wrapper wraps the binary utilities for a bunch of miscellaneous purposes.
These are GNU Binutils when targetting Linux, and a mix of cctools and GNU binutils for Darwin.
[The "Bintools" name is supposed to be a compromise between "Binutils" and "cctools" not denoting any specific implementation.] Specifically, the underlying bintools package, and a C standard library (glibc or Darwin's libSystem, just for the dynamic loader) are all fed in, and dependency finding, hardening (see below), and purity checks for each are handled by the Bintools Wrapper.
Packages typically depend on CC Wrapper, which in turn (at run time) depends on the Bintools Wrapper. 
+
The Bintools Wrapper was only just recently split off from CC Wrapper, so the division of labor is still being worked out.
For example, it shouldn't care about the C standard library, but just take a derivation with the dynamic loader (which happens to be the glibc on linux). Dependency finding however is a task both wrappers will continue to need to share, and probably the most important to understand.
It is currently accomplished by collecting directories of host-platform dependencies (i.e. [var]``buildInputs`` and [var]``nativeBuildInputs``) in environment variables.
The Bintools Wrapper's setup hook causes any [path]``lib``
and [path]``lib64``
subdirectories to be added to [var]``NIX_LDFLAGS``.
Since the CC Wrapper and the Bintools Wrapper use the same strategy, most of the Bintools Wrapper code is sparsely commented and refers to the CC Wrapper.
But the CC Wrapper's code, by contrast, has quite lengthy comments.
The Bintools Wrapper merely cites those, rather than repeating them, to avoid falling out of sync. 
+
A final task of the setup hook is defining a number of standard environment variables to tell build systems which executables fulfill which purpose.
They are defined to just be the base name of the tools, under the assumption that the Bintools Wrapper's binaries will be on the path.
Firstly, this helps poorly-written packages, e.g.
ones that look for just [command]``gcc`` when [var]``CC`` isn't defined yet [command]``clang`` is to be used.
Secondly, this helps packages not get confused when cross-compiling, in which case multiple Bintools Wrappers may simultaneously be in use. footnote:[Each wrapper targets a single platform, so if binaries for multiple platforms are needed, the underlying binaries must be wrapped multiple times. As this is a property of the wrapper itself, the multiple wrappings are needed whether or not the same underlying binaries can target multiple platforms.][var]``BUILD_``- and [var]``TARGET_``-prefixed versions of the normal environment variable are defined for additional Bintools Wrappers, properly disambiguating them. 
+
A problem with this final task is that the Bintools Wrapper is honest and defines [var]``LD`` as [command]``ld``.
Most packages, however, firstly use the C compiler for linking, secondly use [var]``LD`` anyways, defining it as the C compiler, and thirdly, only so define [var]``LD`` when it is undefined as a fallback.
This triple-threat means Bintools Wrapper will break those packages, as LD is already defined as the actual linker which the package won't override yet doesn't want to use.
The workaround is to define, just for the problematic package, [var]``LD`` as the C compiler.
A good way to do this would be [command]``preConfigure = "LD=$CC"``. 
 CC Wrapper::
The CC Wrapper wraps a C toolchain for a bunch of miscellaneous purposes.
Specifically, a C compiler (GCC or Clang), wrapped binary tools, and a C standard library (glibc or Darwin's libSystem, just for the dynamic loader) are all fed in, and dependency finding, hardening (see below), and purity checks for each are handled by the CC Wrapper.
Packages typically depend on the CC Wrapper, which in turn (at run-time) depends on the Bintools Wrapper. 
+
Dependency finding is undoubtedly the main task of the CC Wrapper.
This works just like the Bintools Wrapper, except that any [path]``include``
subdirectory of any relevant dependency is added to [var]``NIX_CFLAGS_COMPILE``.
The setup hook itself contains some lengthy comments describing the exact convoluted mechanism by which this is accomplished. 
+
Similarly, the CC Wrapper follows the Bintools Wrapper in defining standard environment variables with the names of the tools it wraps, for the same reasons described above.
Importantly, while it includes a [command]``cc`` symlink to the c compiler for portability, the [var]``CC`` will be defined using the compiler's "real name" (i.e. [command]``gcc`` or [command]``clang``). This helps lousy build systems that inspect on the name of the compiler rather than run it. 

Here are some more packages that provide a setup hook.
Since the list of hooks is extensible, this is not an exhaustive list.
The mechanism is only to be used as a last resort, so it might cover most uses. 
 Perl::
Adds the [path]``lib/site_perl``
subdirectory of each build input to the [var]``PERL5LIB`` environment variable.
For instance, if [var]``buildInputs`` contains Perl, then the [path]``lib/site_perl``
subdirectory of each input is added to the [var]``PERL5LIB`` environment variable. 
 Python::
Adds the [path]``lib/${python.libPrefix}/site-packages``
subdirectory of each build input to the [var]``PYTHONPATH`` environment variable. 
 pkg-config::
Adds the [path]``lib/pkgconfig``
and [path]``share/pkgconfig``
subdirectories of each build input to the [var]``PKG_CONFIG_PATH`` environment variable. 
 Automake::
Adds the [path]``share/aclocal``
subdirectory of each build input to the [var]``ACLOCAL_PATH`` environment variable. 
 Autoconf::
The [var]``autoreconfHook`` derivation adds [var]``autoreconfPhase``, which runs autoreconf, libtoolize and automake, essentially preparing the configure script in autotools-based builds.
Most autotools-based packages come with the configure script pre-generated, but this hook is necessary for a few packages and when you need to patch the package`'s configure scripts. 
 libxml2::
Adds every file named [path]``catalog.xml``
found under the [path]``xml/dtd``
and [path]``xml/xsl``
subdirectories of each build input to the [var]``XML_CATALOG_FILES`` environment variable. 
 teTeX / TeX Live::
Adds the [path]``share/texmf-nix``
subdirectory of each build input to the [var]``TEXINPUTS`` environment variable. 
 Qt 4::
Sets the [var]``QTDIR`` environment variable to Qt`'s path. 
 gdk-pixbuf::
Exports [var]``GDK_PIXBUF_MODULE_FILE`` environment variable to the builder.
Add librsvg package to [var]``buildInputs`` to get svg support. 
 GHC::
Creates a temporary package database and registers every Haskell build input in it (TODO: how?). 
 GNOME platform::
Hooks related to GNOME platform and related libraries like GLib, GTK and GStreamer are described in <<_sec_language_gnome>>. 
 autoPatchelfHook::
This is a special setup hook which helps in packaging proprietary software in that it automatically tries to find missing shared library dependencies of ELF files based on the given [var]``buildInputs`` and [var]``nativeBuildInputs``. 
+
You can also specify a [var]``runtimeDependencies`` environment variable which lists dependencies that are unconditionally added to all executables. 
+
This is useful for programs that use 
to load libraries at runtime. 
+
In certain situations you may want to run the main command ([command]``autoPatchelf``) of the setup hook on a file or a set of directories instead of unconditionally patching all outputs.
This can be done by setting the [var]``dontAutoPatchelf`` environment variable to a non-empty value. 
+
The [command]``autoPatchelf`` command also recognizes a [parameter]``--no-recurse`` command line flag, which prevents it from recursing into subdirectories. 
 breakpointHook::
This hook will make a build pause instead of stopping when a failure happens.
It prevents nix from cleaning up the build environment immediately and allows the user to attach to a build environment using the [command]``cntr`` command.
Upon build error it will print instructions on how to use [command]``cntr``, which can be used to enter the environment for debugging.
Installing cntr and running the command will provide shell access to the build sandbox of failed build.
At [path]``/var/lib/cntr``
the sandboxed filesystem is mounted.
All commands and files of the system are still accessible within the shell.
To execute commands from the sandbox use the cntr exec subcommand. [command]``cntr`` is only supported on Linux-based platforms.
To use it first add `cntr` to your `environment.systemPackages` on NixOS or alternatively to the root user on non-NixOS systems.
Then in the package that is supposed to be inspected, add `breakpointHook` to ``nativeBuildInputs``. 
+
[source]
----

nativeBuildInputs = [ breakpointHook ];
----

When a build failure happens there will be an instruction printed that shows how to attach with `cntr` to the build sandbox. 
+

.Caution with remote builds
NOTE: This won't work with remote builds as the build environment is on a different machine and can't be accessed by [command]``cntr``.
Remote builds can be turned off by setting `--option builders ''` for [command]``nix-build`` or `--builders ''` for [command]``nix build``. 
+

 installShellFiles::
This hook helps with installing manpages and shell completion files.
It exposes 2 shell functions `installManPage` and `installShellCompletion` that can be used from your `postInstall` hook. 
+
The `installManPage` function takes one or more paths to manpages to install.
The manpages must have a section suffix, and may optionally be compressed (with `$$.$$gz` suffix). This function will place them into the correct directory. 
+
The `installShellCompletion` function takes one or more paths to shell completion files.
By default it will autodetect the shell type from the completion file extension, but you may also specify it by passing one of ``--bash``, ``--fish``, or ``--zsh``.
These flags apply to all paths listed after them (up until another shell flag is given). Each path may also have a custom installation name provided by providing a flag `--name NAME` before the path.
If this flag is not provided, zsh completions will be renamed automatically such that `foobar.zsh` becomes ``\_foobar``. 
+
[source]
----

nativeBuildInputs = [ installShellFiles ];
postInstall = ''
  installManPage doc/foobar.1 doc/barfoo.3
  # explicit behavior
  installShellCompletion --bash --name foobar.bash share/completions.bash
  installShellCompletion --fish --name foobar.fish share/completions.fish
  installShellCompletion --zsh --name _foobar share/completions.zsh
  # implicit behavior
  installShellCompletion share/completions/foobar.{bash,fish,zsh}
'';
----
 libiconv, libintl::
A few libraries automatically add to `NIX_LDFLAGS` their library, making their symbols automatically available to the linker.
This includes libiconv and libintl (gettext). This is done to provide compatibility between GNU Linux, where libiconv and libintl are bundled in, and other systems where that might not be the case.
Sometimes, this behavior is not desired.
To disable this behavior, set ``dontAddExtraLibs``. 
 cmake::
Overrides the default configure phase to run the CMake command.
By default, we use the Make generator of CMake.
In addition, dependencies are added automatically to CMAKE_PREFIX_PATH so that packages are correctly detected by CMake.
Some additional flags are passed in to give similar behavior to configure-based packages.
You can disable this hook`'s behavior by setting configurePhase to a custom value, or by setting dontUseCmakeConfigure.
cmakeFlags controls flags passed only to CMake.
By default, parallel building is enabled as CMake supports parallel building almost everywhere.
When Ninja is also in use, CMake will detect that and use the ninja generator. 
 xcbuildHook::
Overrides the build and install phases to run the "`xcbuild`" command.
This hook is needed when a project only comes with build files for the XCode build system.
You can disable this behavior by setting buildPhase and configurePhase to a custom value.
xcbuildFlags controls flags passed only to xcbuild. 
 Meson::
Overrides the configure phase to run meson to generate Ninja files.
To run these files, you should accompany Meson with ninja.
By default, [var]``enableParallelBuilding`` is enabled as Meson supports parallel building almost everywhere. 

.Variables controlling Meson
[var]``mesonFlags``:::
Controls the flags passed to meson. 

[var]``mesonBuildType``:::
Which https://mesonbuild.com/Builtin-options.html#core-options[--buildtype] to pass to Meson.
We default to ``plain``. 

[var]``mesonAutoFeatures``:::
What value to set https://mesonbuild.com/Builtin-options.html#core-options[-Dauto_features=] to.
We default to [command]``enabled``. 

[var]``mesonWrapMode``:::
What value to set https://mesonbuild.com/Builtin-options.html#core-options[-Dwrap_mode=] to.
We default to [command]``nodownload`` as we disallow network access. 

[var]``dontUseMesonConfigure``:::
Disables using Meson's [var]``configurePhase``. 
 ninja::
Overrides the build, install, and check phase to run ninja instead of make.
You can disable this behavior with the dontUseNinjaBuild, dontUseNinjaInstall, and dontUseNinjaCheck, respectively.
Parallel building is enabled by default in Ninja. 
 unzip::
This setup hook will allow you to unzip .zip files specified in $src.
There are many similar packages like unrar, undmg, etc. 
 wafHook::
Overrides the configure, build, and install phases.
This will run the "waf" script used by many projects.
If wafPath (default ./waf) doesn`'t exist, it will copy the version of waf available in Nixpkgs.
wafFlags can be used to pass flags to the waf script. 
 scons::
Overrides the build, install, and check phases.
This uses the scons build system as a replacement for make.
scons does not provide a configure phase, so everything is managed at build and install time. 


[[_sec_purity_in_nixpkgs]]
== Purity in Nixpkgs


[measures taken to prevent dependencies on packages outside the store, and what you can do to prevent them] 

GCC doesn't search in locations such as [path]``/usr/include``
.
In fact, attempts to add such directories through the [option]``-I`` flag are filtered out.
Likewise, the linker (from GNU binutils) doesn't search in standard locations such as [path]``/usr/lib``
.
Programs built on Linux are linked against a GNU C Library that likewise doesn't search in the default system locations. 

[[_sec_hardening_in_nixpkgs]]
== Hardening in Nixpkgs


There are flags available to harden packages at compile or link-time.
These can be toggled using the [var]``stdenv.mkDerivation`` parameters [var]``hardeningDisable`` and [var]``hardeningEnable``. 

Both parameters take a list of flags as strings.
The special [var]``"all"`` flag can be passed to [var]``hardeningDisable`` to turn off all hardening.
These flags can also be used as environment variables for testing or development purposes. 

The following flags are enabled by default and might require disabling with [var]``hardeningDisable`` if the program to package is incompatible. 

[var]``format``::
Adds the [option]``-Wformat -Wformat-security -Werror=format-security`` compiler options.
At present, this warns about calls to [var]``printf`` and [var]``scanf`` functions where the format string is not a string literal and there are no format arguments, as in ``printf(foo);``.
This may be a security hole if the format string came from untrusted input and contains ``%n``. 
+
This needs to be turned off or fixed for errors similar to: 
+


[source]
----

/tmp/nix-build-zynaddsubfx-2.5.2.drv-0/zynaddsubfx-2.5.2/src/UI/guimain.cpp:571:28: error: format not a string literal and no format arguments [-Werror=format-security]
         printf(help_message);
                            ^
cc1plus: some warnings being treated as errors
----
[var]``stackprotector``::
Adds the [option]``-fstack-protector-strong --param ssp-buffer-size=4`` compiler options.
This adds safety checks against stack overwrites rendering many potential code injection attacks into aborting situations.
In the best case this turns code injection vulnerabilities into denial of service or into non-issues (depending on the application). 
+
This needs to be turned off or fixed for errors similar to: 
+


[source]
----

bin/blib.a(bios_console.o): In function `bios_handle_cup':
/tmp/nix-build-ipxe-20141124-5cbdc41.drv-0/ipxe-5cbdc41/src/arch/i386/firmware/pcbios/bios_console.c:86: undefined reference to `__stack_chk_fail'
----
[var]``fortify``::
Adds the [option]``-O2 -D_FORTIFY_SOURCE=2`` compiler options.
During code generation the compiler knows a great deal of information about buffer sizes (where possible), and attempts to replace insecure unlimited length buffer function calls with length-limited ones.
This is especially useful for old, crufty code.
Additionally, format strings in writable memory that contain '%n' are blocked.
If an application depends on such a format string, it will need to be worked around. 
+
Additionally, some warnings are enabled which might trigger build failures if compiler warnings are treated as errors in the package build.
In this case, set [option]``NIX_CFLAGS_COMPILE`` to [option]``-Wno-error=warning-type``. 
+
This needs to be turned off or fixed for errors similar to: 
+


[source]
----

malloc.c:404:15: error: return type is an incomplete type
malloc.c:410:19: error: storage size of 'ms' isn't known
----
+

[source]
----

strdup.h:22:1: error: expected identifier or '(' before '__extension__'
----
+

[source]
----

strsep.c:65:23: error: register name not specified for 'delim'
----
+

[source]
----

installwatch.c:3751:5: error: conflicting types for '__open_2'
----
+

[source]
----

fcntl2.h:50:4: error: call to '__open_missing_mode' declared with attribute error: open with O_CREAT or O_TMPFILE in second argument needs 3 arguments
----
[var]``pic``::
Adds the [option]``-fPIC`` compiler options.
This options adds support for position independent code in shared libraries and thus making ASLR possible. 
+
Most notably, the Linux kernel, kernel modules and other code not running in an operating system environment like boot loaders won't build with PIC enabled.
The compiler will is most cases complain that PIC is not supported for a specific build. 
+
This needs to be turned off or fixed for assembler errors similar to: 
+


[source]
----

ccbLfRgg.s: Assembler messages:
ccbLfRgg.s:33: Error: missing or invalid displacement expression `private_key_len@GOTOFF'
----
[var]``strictoverflow``::
Signed integer overflow is undefined behaviour according to the C standard.
If it happens, it is an error in the program as it should check for overflow before it can happen, not afterwards.
GCC provides built-in functions to perform arithmetic with overflow checking, which are correct and faster than any custom implementation.
As a workaround, the option [option]``-fno-strict-overflow`` makes gcc behave as if signed integer overflows were defined. 
+
This flag should not trigger any build or runtime errors. 

[var]``relro``::
Adds the [option]``-z relro`` linker option.
During program load, several ELF memory sections need to be written to by the linker, but can be turned read-only before turning over control to the program.
This prevents some GOT (and .dtors) overwrite attacks, but at least the part of the GOT used by the dynamic linker (.got.plt) is still vulnerable. 
+
This flag can break dynamic shared object loading.
For instance, the module systems of Xorg and OpenCV are incompatible with this flag.
In almost all cases the [var]``bindnow`` flag must also be disabled and incompatible programs typically fail with similar errors at runtime. 

[var]``bindnow``::
Adds the [option]``-z bindnow`` linker option.
During program load, all dynamic symbols are resolved, allowing for the complete GOT to be marked read-only (due to [var]``relro``). This prevents GOT overwrite attacks.
For very large applications, this can incur some performance loss during initial load while symbols are resolved, but this shouldn't be an issue for daemons. 
+
This flag can break dynamic shared object loading.
For instance, the module systems of Xorg and PHP are incompatible with this flag.
Programs incompatible with this flag often fail at runtime due to missing symbols, like: 
+


[source]
----

intel_drv.so: undefined symbol: vgaHWFreeHWRec
----


The following flags are disabled by default and should be enabled with [var]``hardeningEnable`` for packages that take untrusted input like network services. 

[var]``pie``::
Adds the [option]``-fPIE`` compiler and [option]``-pie`` linker options.
Position Independent Executables are needed to take advantage of Address Space Layout Randomization, supported by modern kernel versions.
While ASLR can already be enforced for data areas in the stack and heap (brk and mmap), the code areas must be compiled as position-independent.
Shared libraries already do this with the [var]``pic`` flag, so they gain ASLR automatically, but binary .text regions need to be build with [var]``pie`` to gain ASLR.
When this happens, ROP attacks are much harder since there are no static locations to bounce off of during a memory corruption attack. 


For more in-depth information on these hardening flags and hardening in general, refer to the https://wiki.debian.org/Hardening[Debian Wiki], https://wiki.ubuntu.com/Security/Features[Ubuntu Wiki], https://wiki.gentoo.org/wiki/Project:Hardened[Gentoo Wiki], and the https://wiki.archlinux.org/index.php/DeveloperWiki:Security[ Arch Wiki]. 