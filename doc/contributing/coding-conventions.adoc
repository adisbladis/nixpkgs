[[_chap_conventions]]
= Coding conventions
:doctype: book
:sectnums:
:toc: left
:icons: font
:experimental:
:sourcedir: .
:imagesdir: ./images

[[_sec_syntax]]
== Syntax

* Use 2 spaces of indentation per indentation level in Nix expressions, 4 spaces in shell scripts. 
* Do not use tab characters, i.e. configure your editor to use soft tabs. For instance, use `(setq-default indent-tabs-mode nil)` in Emacs. Everybody has different tab settings so it`'s asking for trouble. 
* Use `lowerCamelCase` for variable names, not ``UpperCamelCase``. Note, this rule does not apply to package attribute names, which instead follow the rules in <<_sec_package_naming>>. 
* Function calls with attribute set arguments are written as 
+
[source]
----

foo {
  arg = ...;
}
----

not 
[source]
----

foo
{
  arg = ...;
}
----

Also fine is 
[source]
----

foo { arg = ...; }
----

if it's a short call. 
* In attribute sets or lists that span multiple lines, the attribute names or list elements should be aligned: 
+
[source]
----

# A long list.
list = [
  elem1
  elem2
  elem3
];

# A long attribute set.
attrs = {
  attr1 = short_expr;
  attr2 =
    if true then big_expr else big_expr;
};

# Combined
listOfAttrs = [
  {
    attr1 = 3;
    attr2 = "fff";
  }
  {
    attr1 = 5;
    attr2 = "ggg";
  }
];
----
* Short lists or attribute sets can be written on one line: 
+
[source]
----

# A short list.
list = [ elem1 elem2 elem3 ];

# A short set.
attrs = { x = 1280; y = 1024; };
----
* Breaking in the middle of a function argument can give hard-to-read code, like 
+
[source]
----

someFunction { x = 1280;
  y = 1024; } otherArg
  yetAnotherArg
----

(especially if the argument is very large, spanning multiple lines). 
+ 
Better: 
+
[source]
----

someFunction
  { x = 1280; y = 1024; }
  otherArg
  yetAnotherArg
----

or 
[source]
----

let res = { x = 1280; y = 1024; };
in someFunction res otherArg yetAnotherArg
----
* The bodies of functions, asserts, and withs are not indented to prevent a lot of superfluous indentation levels, i.e. 
+
[source]
----

{ arg1, arg2 }:
assert system == "i686-linux";
stdenv.mkDerivation { ...
----

not 
[source]
----

{ arg1, arg2 }:
  assert system == "i686-linux";
    stdenv.mkDerivation { ...
----
* Function formal arguments are written as: 
+
[source]
----

{ arg1, arg2, arg3 }:
----

but if they don't fit on one line they're written as: 
[source]
----

{ arg1, arg2, arg3
, arg4, ...
, # Some comment...
  argN
}:
----
* Functions should list their expected arguments as precisely as possible. That is, write 
+
[source]
----

{ stdenv, fetchurl, perl }: ...
----

instead of 
[source]
----

args: with args; ...
----

or 
[source]
----

{ stdenv, fetchurl, perl, ... }: ...
----
+ 
For functions that are truly generic in the number of arguments (such as wrappers around [var]``mkDerivation``) that have some required arguments, you should write them using an ``@``-pattern: 
+
[source]
----

{ stdenv, doCoverageAnalysis ? false, ... } @ args:

stdenv.mkDerivation (args // {
  ... if doCoverageAnalysis then "bla" else "" ...
})
----

instead of 
[source]
----

args:

args.stdenv.mkDerivation (args // {
  ... if args ? doCoverageAnalysis && args.doCoverageAnalysis then "bla" else "" ...
})
----


[[_sec_package_naming]]
== Package naming


The key words __must__, __must not__, __required__, __shall__, __shall not__, __should__, __should not__, __recommended__, __may__, and _optional_ in this section are to be interpreted as described in https://tools.ietf.org/html/rfc2119[RFC 2119].
Only _emphasized_ words are to be interpreted in this way. 

In Nixpkgs, there are generally three different names associated with a package: 

* The [var]``name`` attribute of the derivation (excluding the version part). This is what most users see, in particular when using [command]``nix-env``. 
* The variable name used for the instantiated package in [path]``all-packages.nix`` , and when passing it as a dependency to other functions. Typically this is called the __package attribute name__. This is what Nix expression authors see. It can also be used when installing using [command]``nix-env -iA``. 
* The filename for (the directory containing) the Nix expression. 

Most of the time, these are the same.
For instance, the package `e2fsprogs` has a [var]``name`` attribute ``"e2fsprogs-[replaceable]``version``"``, is bound to the variable name [var]``e2fsprogs`` in [path]``all-packages.nix``
, and the Nix expression is in [path]``pkgs/os-specific/linux/e2fsprogs/default.nix``
. 

There are a few naming guidelines: 

* The `name` attribute _should_ be identical to the upstream package name. 
* The `name` attribute _must not_ contain uppercase letters -- e.g., `"mplayer-1.0rc2"` instead of ``"MPlayer-1.0rc2"``. 
* The version part of the `name` attribute _must_ start with a digit (following a dash) -- e.g., ``"hello-0.3.1rc2"``. 
* If a package is not a release but a commit from a repository, then the version part of the name _must_ be the date of that (fetched) commit. The date _must_ be in `"YYYY-MM-DD"` format. Also append `"unstable"` to the name - e.g., ``"pkgname-unstable-2014-09-23"``. 
* Dashes in the package name _should_ be preserved in new variable names, rather than converted to underscores or camel cased -- e.g., [var]``http-parser`` instead of [var]``http_parser`` or [var]``httpParser``. The hyphenated style is preferred in all three package names. 
* If there are multiple versions of a package, this _should_ be reflected in the variable names in [path]``all-packages.nix`` , e.g. [var]``json-c-0-9`` and [var]``json-c-0-11``. If there is an obvious "`default`" version, make an attribute like ``json-c = json-c-0-9;``. See also <<_sec_versioning>>


[[_sec_organisation]]
== File naming and organisation


Names of files and directories should be in lowercase, with dashes between words -- not in camel case.
For instance, it should be [path]``all-packages.nix``
, not [path]``allPackages.nix``
 or [path]``AllPackages.nix``
. 

[[_sec_hierarchy]]
=== Hierarchy


Each package should be stored in its own directory somewhere in the [path]``pkgs/``
 tree, i.e.
in [path]``pkgs/category/subcategory/.../pkgname``
.
Below are some rules for picking the right category for a package.
Many packages fall under several categories; what matters is the _primary_ purpose of a package.
For example, the `libxml2` package builds both a library and some tools; but it`'s a library foremost, so it goes under [path]``pkgs/development/libraries``
. 

When in doubt, consider refactoring the [path]``pkgs/``
 tree, e.g.
creating new categories or splitting up an existing category. 
 If it`'s used to support __software development__:::
 If it`'s a _library_ used by other packages::::
[path]``development/libraries``
(e.g. [path]``libxml2``
) 
 If it`'s a __compiler__::::
[path]``development/compilers``
(e.g. [path]``gcc``
) 
 If it`'s an __interpreter__::::
[path]``development/interpreters``
(e.g. [path]``guile``
) 
 If it`'s a (set of) development __tool(s)__::::
 If it`'s a _parser generator_ (including lexers):::::
[path]``development/tools/parsing``
(e.g. [path]``bison``
, [path]``flex``
) 
 If it`'s a __build manager__:::::
[path]``development/tools/build-managers``
(e.g. [path]``gnumake``
) 
 Else:::::
[path]``development/tools/misc``
(e.g. [path]``binutils``
) 
 Else::::
[path]``development/misc``
 If it`'s a (set of) __tool(s)__:::
(A tool is a relatively small program, especially one intended to be used non-interactively.) 
 If it`'s for __networking__::::
[path]``tools/networking``
(e.g. [path]``wget``
) 
 If it`'s for __text processing__::::
[path]``tools/text``
(e.g. [path]``diffutils``
) 
 If it`'s a __system utility__, i.e., something related or essential to the operation of a system::::
[path]``tools/system``
(e.g. [path]``cron``
) 
 If it`'s an _archiver_ (which may include a compression function)::::
[path]``tools/archivers``
(e.g. [path]``zip``
, [path]``tar``
) 
 If it`'s a _compression_ program::::
[path]``tools/compression``
(e.g. [path]``gzip``
, [path]``bzip2``
) 
 If it`'s a __security__-related program::::
[path]``tools/security``
(e.g. [path]``nmap``
, [path]``gnupg``
) 
 Else::::
[path]``tools/misc``
 If it`'s a __shell__:::
[path]``shells``
(e.g. [path]``bash``
) 
 If it`'s a __server__:::
 If it`'s a web server::::
[path]``servers/http``
(e.g. [path]``apache-httpd``
) 
 If it`'s an implementation of the X Windowing System::::
[path]``servers/x11``
(e.g. [path]``xorg``
-- this includes the client libraries and programs) 
 Else::::
[path]``servers/misc``
 If it`'s a __desktop environment__:::
[path]``desktops``
(e.g. [path]``kde``
, [path]``gnome``
, [path]``enlightenment``
) 
 If it`'s a __window manager__:::
[path]``applications/window-managers``
(e.g. [path]``awesome``
, [path]``stumpwm``
) 
 If it`'s an __application__:::
A (typically large) program with a distinct user interface, primarily used interactively. 
 If it`'s a __version management system__::::
[path]``applications/version-management``
(e.g. [path]``subversion``
) 
 If it`'s for __video playback / editing__::::
[path]``applications/video``
(e.g. [path]``vlc``
) 
 If it`'s for __graphics viewing / editing__::::
[path]``applications/graphics``
(e.g. [path]``gimp``
) 
 If it`'s for __networking__::::
 If it`'s a __mailreader__:::::
[path]``applications/networking/mailreaders``
(e.g. [path]``thunderbird``
) 
 If it`'s a __newsreader__:::::
[path]``applications/networking/newsreaders``
(e.g. [path]``pan``
) 
 If it`'s a __web browser__:::::
[path]``applications/networking/browsers``
(e.g. [path]``firefox``
) 
 Else:::::
[path]``applications/networking/misc``
 Else::::
[path]``applications/misc``
 If it`'s _data_ (i.e., does not have a straight-forward executable semantics):::
 If it`'s a __font__::::
[path]``data/fonts``
 If it`'s an __icon theme__::::
[path]``data/icons``
 If it`'s related to __SGML/XML processing__::::
 If it`'s an __XML DTD__:::::
[path]``data/sgml+xml/schemas/xml-dtd``
(e.g. [path]``docbook``
) 
 If it`'s an __XSLT stylesheet__:::::
(Okay, these are executable...) 
+
[path]``data/sgml+xml/stylesheets/xslt``
(e.g. [path]``docbook-xsl``
) 
 If it`'s a _theme_ for a __desktop environment__, a _window manager_ or a __display manager__::::
[path]``data/themes``
 If it`'s a __game__:::
[path]``games``
 Else:::
[path]``misc``


[[_sec_versioning]]
=== Versioning


Because every version of a package in Nixpkgs creates a potential maintenance burden, old versions of a package should not be kept unless there is a good reason to do so.
For instance, Nixpkgs contains several versions of GCC because other packages don`'t build with the latest version of GCC.
Other examples are having both the latest stable and latest pre-release version of a package, or to keep several major releases of an application that differ significantly in functionality. 

If there is only one version of a package, its Nix expression should be named [path]``e2fsprogs/default.nix``
.
If there are multiple versions, this should be reflected in the filename, e.g. [path]``e2fsprogs/1.41.8.nix``
 and [path]``e2fsprogs/1.41.9.nix``
.
The version in the filename should leave out unnecessary detail.
For instance, if we keep the latest Firefox 2.0.x and 3.5.x versions in Nixpkgs, they should be named [path]``firefox/2.0.nix``
 and [path]``firefox/3.5.nix``
, respectively (which, at a given point, might contain versions `2.0.0.20` and ``3.5.4``). If a version requires many auxiliary files, you can use a subdirectory for each version, e.g. [path]``firefox/2.0/default.nix``
 and [path]``firefox/3.5/default.nix``
. 

All versions of a package _must_ be included in [path]``all-packages.nix``
 to make sure that they evaluate correctly. 

[[_sec_sources]]
== Fetching Sources


There are multiple ways to fetch a package source in nixpkgs.
The general guideline is that you should package reproducible sources with a high degree of availability.
Right now there is only one fetcher which has mirroring support and that is ``fetchurl``.
Note that you should also prefer protocols which have a corresponding proxy environment variable. 

You can find many source fetch helpers in ``pkgs/build-support/fetch*``. 

In the file `pkgs/top-level/all-packages.nix` you can find fetch helpers, these have names on the form ``fetchFrom*``.
The intention of these are to provide snapshot fetches but using the same api as some of the version controlled fetchers from ``pkgs/build-support/``.
As an example going from bad to good: 

* Bad: Uses `git://` which won't be proxied. 
+
[source]
----

src = fetchgit {
  url = "git://github.com/NixOS/nix.git";
  rev = "1f795f9f44607cc5bec70d1300150bfefcef2aae";
  sha256 = "1cw5fszffl5pkpa6s6wjnkiv6lm5k618s32sp60kvmvpy7a2v9kg";
}
----
* Better: This is ok, but an archive fetch will still be faster. 
+
[source]
----

src = fetchgit {
  url = "https://github.com/NixOS/nix.git";
  rev = "1f795f9f44607cc5bec70d1300150bfefcef2aae";
  sha256 = "1cw5fszffl5pkpa6s6wjnkiv6lm5k618s32sp60kvmvpy7a2v9kg";
}
----
* Best: Fetches a snapshot archive and you get the rev you want. 
+
[source]
----

src = fetchFromGitHub {
  owner = "NixOS";
  repo = "nix";
  rev = "1f795f9f44607cc5bec70d1300150bfefcef2aae";
  sha256 = "1i2yxndxb6yc9l6c99pypbd92lfq5aac4klq7y2v93c9qvx2cgpc";
}
----

Find the value to put as `sha256` by running `nix run -f '<nixpkgs>' nix-prefetch-github -c nix-prefetch-github --rev 1f795f9f44607cc5bec70d1300150bfefcef2aae NixOS nix` or ``nix-prefetch-url --unpack https://github.com/NixOS/nix/archive/1f795f9f44607cc5bec70d1300150bfefcef2aae.tar.gz``. 


[[_sec_source_hashes]]
== Obtaining source hash


Preferred source hash type is sha256.
There are several ways to get it. 

. Prefetch URL (with ``nix-prefetch-[replaceable]``XXX``[replaceable]``URL````, where [replaceable]``XXX`` is one of ``url``, ``git``, ``hg``, ``cvs``, ``bzr``, ``svn``). Hash is printed to stdout. 
. Prefetch by package source (with ``nix-prefetch-url '<nixpkgs>' -A [replaceable]``PACKAGE``.src``, where [replaceable]``PACKAGE`` is package attribute name). Hash is printed to stdout. 
+ 
This works well when you've upgraded existing package version and want to find out new hash, but is useless if package can't be accessed by attribute or package has multiple sources (``$$.$$srcs``, architecture-dependent sources, etc). 
. Upstream provided hash: use it when upstream provides `sha256` or `sha512` (when upstream provides ``md5``, don't use it, compute `sha256` instead). 
+ 
A little nuance is that `nix-prefetch-*` tools produce hash encoded with ``base32``, but upstream usually provides hexadecimal (``base16``) encoding.
Fetchers understand both formats.
Nixpkgs does not standardize on any one format. 
+ 
You can convert between formats with nix-hash, for example: 
+
----

$ nix-hash --type sha256 --to-base32`HASH`
----
. Extracting hash from local source tarball can be done with ``sha256sum``. Use `nix-prefetch-url file:///path/to/tarball ` if you want base32 hash. 
. Fake hash: set fake hash in package expression, perform build and extract correct hash from error Nix prints. 
+ 
For package updates it is enough to change one symbol to make hash fake.
For new packages, you can use ``lib.fakeSha256``, `lib.fakeSha512` or any other fake hash. 
+ 
This is last resort method when reconstructing source URL is non-trivial and `nix-prefetch-url -A` isn't applicable (for example, https://github.com/NixOS/nixpkgs/blob/d2ab091dd308b99e4912b805a5eb088dd536adb9/pkgs/applications/video/kodi/default.nix#L73[ one of kodi dependencies]). The easiest way then would be replace hash with a fake one and rebuild.
Nix build will fail and error message will contain desired hash. 
+
WARNING: This method has security problems.
Check below for details. 
+



[[_sec_source_hashes_security]]
=== Obtaining hashes securely


Let's say Man-in-the-Middle (MITM) sits close to your network.
Then instead of fetching source you can fetch malware, and instead of source hash you get hash of malware.
Here are security considerations for this scenario: 

* `http://` URLs are not secure to prefetch hash from; 
* hashes from upstream (in method 3) should be obtained via secure protocol; 
* `https://` URLs are secure in methods 1, 2, 3; 
* `https://` URLs are not secure in method 5. When obtaining hashes with fake hash method, TLS checks are disabled. So refetch source hash from several different networks to exclude MITM scenario. Alternatively, use fake hash method to make Nix error, but instead of extracting hash from error, extract `https://` URL and prefetch it with method 1. 


[[_sec_patches]]
== Patches


Patches available online should be retrieved using ``fetchpatch``. 


[source]
----

patches = [
  (fetchpatch {
    name = "fix-check-for-using-shared-freetype-lib.patch";
    url = "http://git.ghostscript.com/?p=ghostpdl.git;a=patch;h=8f5d285";
    sha256 = "1f0k043rng7f0rfl9hhb89qzvvksqmkrikmm38p61yfx51l325xr";
  })
];
----

Otherwise, you can add a `$$.$$patch` file to the `nixpkgs` repository.
In the interest of keeping our maintenance burden to a minimum, only patches that are unique to `nixpkgs` should be added in this way. 


[source]
----

patches = [ ./0001-changes.patch ];
----

If you do need to do create this sort of patch file, one way to do so is with git: 

. Move to the root directory of the source code you're patching. 
+
----

$ cd the/program/source
----
. If a git repository is not already present, create one and stage all of the source files. 
+
----

$ git init
$ git add .
----
. Edit some files to make whatever changes need to be included in the patch. 
. Use git to create a diff, and pipe the output to a patch file: 
+
----

$ git diff > nixpkgs/pkgs/the/package/0001-changes.patch
----
